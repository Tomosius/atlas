{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Atlas MCP","text":"<p>One tool. Ten verbs. Instant project knowledge for AI coding agents.</p> <p>Atlas is an MCP (Model Context Protocol) server that gives AI coding agents structured knowledge about the project they are working in. It detects your stack, extracts real config values, and serves pre-built coding rules \u2014 instantly.</p>"},{"location":"#why-atlas","title":"Why Atlas?","text":"<p>When an AI agent starts working on your codebase, it knows nothing about your project. It doesn't know you use ruff with <code>line-length=88</code>, that your pytest markers are <code>unit</code> and <code>integration</code>, or that your project follows a specific commit convention.</p> <p>Atlas solves this by pre-computing a set of retrieve files \u2014 Markdown docs with your actual config values injected \u2014 that agents can read in milliseconds.</p> <pre><code>agent: \"atlas retrieve python ruff\"\natlas: [returns rules.md with your actual ruff config values already injected]\n</code></pre>"},{"location":"#how-it-works","title":"How it works","text":"<pre><code>atlas init          \u2192 detect stack, install modules, build retrieve files\natlas retrieve ruff \u2192 serve pre-built rules instantly (file read, no computation)\natlas add pytest    \u2192 install module, rebuild retrieve files\natlas sync          \u2192 re-scan config, update changed values\natlas just test     \u2192 run tests, augment errors with relevant rule hints\n</code></pre>"},{"location":"#install","title":"Install","text":"<pre><code># Zero-install with uvx (recommended)\nuvx atlas-mcp\n\n# Or install globally\nuv tool install atlas-mcp\n</code></pre>"},{"location":"#configure-in-your-editor","title":"Configure in your editor","text":"Claude DesktopZed <pre><code>{\n  \"mcpServers\": {\n    \"atlas\": {\n      \"command\": \"uvx\",\n      \"args\": [\"atlas-mcp\"]\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"context_servers\": {\n    \"atlas\": {\n      \"command\": \"uvx\",\n      \"args\": [\"atlas-mcp\"]\n    }\n  }\n}\n</code></pre>"},{"location":"#quick-navigation","title":"Quick navigation","text":"<ul> <li>Installation \u2192</li> <li>How Atlas works \u2192</li> <li>All 10 verbs \u2192</li> <li>Module catalogue \u2192</li> <li>Development guide \u2192</li> </ul>"},{"location":"commit-rules/","title":"SEMANTIC COMMIT PROTOCOL \u2014 Atlas MCP","text":"<p>ROLE: You are a Senior Release Engineer. TASK: Produce the best possible semantic commit message for the current staged changes.</p> <p>HARD RULES (always enforced): 1. One logical change per commit. Mixed concerns \u2192 split. 2. Subject: imperative mood, \u226472 chars, no <code>.</code> <code>...</code> <code>\u2026</code> <code>!</code> <code>?</code> ending, no emojis, no banned verbs. 3. Scope: domain name (not filename), \u226424 chars, lowercase, or omitted. 4. Never hallucinate ticket numbers, versions, benchmarks, or business context. 5. Output raw commit text only \u2014 no commentary, no wrappers.</p> <p>Execution checklist (run before every output): 1. Read context (see INPUT STRATEGY below) \u2014 diff alone is not enough. 2. Atomic? \u2192 If not, split (chat: warn; direct-commit: abort). 3. Type \u2192 highest match from TYPE SELECTION. 4. Scope \u2192 pick from PROJECT SCOPES table, or omit. 5. Subject \u226472 chars, imperative, no banned verbs, no trailing punctuation. 6. Body required? \u2192 Check BODY RULES. 7. Output \u2192 raw text only.</p>"},{"location":"commit-rules/#input-strategy-read-files-not-just-the-diff","title":"INPUT STRATEGY \u2014 Read Files, Not Just the Diff","text":"<p>A diff alone is insufficient context. Diffs show lines added/removed but not the purpose of the surrounding code, the issue being worked on, or the architectural intent. Before writing a commit message, always gather context in this order:</p>"},{"location":"commit-rules/#step-1-check-claudemd-for-current-issue","title":"Step 1 \u2014 Check CLAUDE.md for current issue","text":"<pre><code>cat CLAUDE.md\n</code></pre> <p>This tells you: - Which issue is currently in-progress (the \"Current Issue\" field). - Which phase and milestone the work belongs to. - Links to the GitHub issue for full acceptance criteria.</p>"},{"location":"commit-rules/#step-2-read-the-github-issue","title":"Step 2 \u2014 Read the GitHub issue","text":"<pre><code>gh issue view &lt;number&gt; --repo Tomosius/atlas\n</code></pre> <p>This tells you: - The exact title and intent of the work. - What \"done\" looks like for this issue. - Which scope and type are most appropriate.</p>"},{"location":"commit-rules/#step-3-read-the-changed-files-in-full","title":"Step 3 \u2014 Read the changed files in full","text":"<p>For each file touched by the staged changes, read it completely \u2014 not just the diff hunks. A diff shows you what changed; the file shows you what it is now and why it exists.</p> <pre><code># See which files are staged\ngit diff --cached --name-only\n\n# Read each one\ncat src/atlas/core/scanner.py\ncat tests/test_scanner.py\n</code></pre> <p>Reading the full file reveals: - The module's purpose and structure (not just the changed lines). - How new code fits into existing patterns. - Whether the change is truly atomic or mixes concerns. - The correct scope (a file named <code>scanner.py</code> clearly maps to <code>scanner</code>).</p>"},{"location":"commit-rules/#step-4-then-look-at-the-diff","title":"Step 4 \u2014 Then look at the diff","text":"<pre><code>git diff --cached\n</code></pre> <p>Now that you understand the files and the issue, the diff tells you the precise mechanics of what changed. Use it to write accurate HOW bullets in the body.</p>"},{"location":"commit-rules/#step-5-check-plan-documents-if-the-purpose-is-still-unclear","title":"Step 5 \u2014 Check plan documents if the purpose is still unclear","text":"<p>The <code>plan/</code> folder contains the authoritative design for every component. If a change touches detection, scanner, modules, etc. \u2014 read the relevant plan doc to understand the intended behavior.</p> <pre><code>cat plan/01-ARCHITECTURE.md\ncat plan/02-DESIGN-PATTERNS.md\n</code></pre>"},{"location":"commit-rules/#why-this-matters","title":"Why this matters","text":"Context Source What it tells you <code>CLAUDE.md</code> Current issue number, phase, workflow state <code>gh issue view</code> Exact intent and acceptance criteria Full file read Module purpose, patterns, correct scope Diff Precise mechanical change (HOW bullets) Plan docs Architectural intent if purpose is unclear <p>Never write a commit message from the diff alone. A diff of 10 added lines in <code>modules.py</code> could be <code>feat(modules)</code>, <code>fix(modules)</code>, or <code>refactor(modules)</code> depending on context only the full file and issue reveal.</p>"},{"location":"commit-rules/#atomicity-the-most-important-rule","title":"ATOMICITY \u2014 THE MOST IMPORTANT RULE","text":"<p>One commit = one logical change that can be reverted independently.</p>"},{"location":"commit-rules/#why-atomic-commits-matter-here","title":"Why atomic commits matter here","text":"<p>Each issue in this project maps to a single logical concern (see GitHub Issues). A single issue may and should produce multiple commits \u2014 one per logical sub-step. It is always better to commit more often than less.</p> <pre><code>Issue #26: Create modules.py: install_module\n  commit 1 \u2192 feat(modules): add install_module signature and validation\n  commit 2 \u2192 feat(modules): load module bundle from warehouse\n  commit 3 \u2192 feat(modules): scan and enrich module config on install\n  commit 4 \u2192 feat(modules): write module to .atlas and update manifest\n  commit 5 \u2192 test(modules): add install_module happy path tests\n  commit 6 \u2192 test(modules): add conflict and not-found error tests\n</code></pre> <p>Never bundle two independent outcomes into one commit, even if they are small. A reviewer must be able to revert any single commit without unintended side effects.</p>"},{"location":"commit-rules/#pass-atomicity-when-all-are-true","title":"Pass atomicity when ALL are true","text":"<ul> <li>One primary outcome (runtime, operational, or documentation).</li> <li>Reverting the entire commit would make sense as one undo operation.</li> </ul>"},{"location":"commit-rules/#tests-with-implementation-exception","title":"Tests-with-Implementation Exception","text":"<p>Tests that validate the same implementation ARE part of the same atomic commit. A <code>feat</code> commit that adds a feature plus its direct tests is one atomic unit. Do NOT split tests from the exact implementation they test.</p>"},{"location":"commit-rules/#split-when-any-are-true","title":"Split when ANY are true","text":"<ul> <li>Multiple independent outcomes exist.</li> <li>Reverting part of the diff would break unrelated behavior.</li> <li>Changes span unrelated domains with separate user impact.</li> </ul>"},{"location":"commit-rules/#non-atomic-diff-protocol","title":"Non-Atomic Diff Protocol","text":"<p>In chat mode, output:</p> <pre><code>WARNING: This diff is not atomic.\n\nReason: &lt;clear reason&gt;\n\nRecommended split:\n1. &lt;type&gt;(&lt;scope&gt;): &lt;first logical change&gt;\n2. &lt;type&gt;(&lt;scope&gt;): &lt;second logical change&gt;\n</code></pre> <p>In direct-commit mode, abort \u2014 never output a warning as a commit message.</p>"},{"location":"commit-rules/#message-structure","title":"MESSAGE STRUCTURE","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n&lt;blank line&gt;\n&lt;WHY \u2014 motivation, bug cause, user impact&gt;\n\n- &lt;HOW bullet 1&gt;\n- &lt;HOW bullet 2&gt;  (max 3 bullets)\n&lt;blank line&gt;\n&lt;footers&gt;\n</code></pre> <p>Scope is optional. Subject is always required. Body and footers are conditional (see Sections below).</p>"},{"location":"commit-rules/#decision-order-mandatory","title":"DECISION ORDER (MANDATORY)","text":"<ol> <li>Read CLAUDE.md \u2014 identify current issue number and phase.</li> <li>Read the GitHub issue (<code>gh issue view &lt;n&gt; --repo Tomosius/atlas</code>) \u2014 understand intent.</li> <li>Read all changed files in full (<code>git diff --cached --name-only</code>, then read each file).</li> <li>Read the diff (<code>git diff --cached</code>) \u2014 now you understand what changed AND why.</li> <li>Check special cases: revert (only if hash provided), merge (only if metadata present).</li> <li>Run atomicity gate.</li> <li>If non-atomic \u2192 warn (chat) or abort (direct-commit).</li> <li>Identify primary vs supporting changes.</li> <li>Select type (priority order below).</li> <li>Select scope from PROJECT SCOPES table.</li> <li>Write subject.</li> <li>Add body and footers if required.</li> <li>Run pre-output verification.</li> <li>Output only the final payload.</li> </ol>"},{"location":"commit-rules/#type-selection-strict-priority","title":"TYPE SELECTION (STRICT PRIORITY)","text":"<p>If multiple types apply to the same primary outcome, use the top-most match:</p> Priority Type When to Use 1 fix Corrects incorrect behavior (user-facing bugs, internal bugs, security bugs) 2 feat Adds new user-facing functionality 3 perf Performance improvement (include benchmark in body if available) 4 refactor No runtime behavior change. File moves, extraction, deprecation markers 5 build Build system, dependencies, toolchain (uv, pip, docker, hatch) 6 test Adding or correcting tests only 7 ci CI pipeline/config only 8 docs Documentation files only (README, CLAUDE.md, ADRs, public docstrings) 9 style Formatting, whitespace (no logic change) 10 chore Maintenance with no better type (.gitignore, removing unused files) <p>Special types: - <code>revert</code> \u2014 ONLY when original commit hash is explicitly provided. - <code>merge</code> \u2014 ONLY when merge metadata is present. - <code>security</code> \u2014 ONLY if project conventions explicitly allow it; otherwise use <code>fix</code>.</p>"},{"location":"commit-rules/#project-scopes","title":"PROJECT SCOPES","text":"<p>These are the canonical scopes for this project. Use the scope that matches the domain of the change, not the filename or folder name.</p>"},{"location":"commit-rules/#core-engine-scopes","title":"Core Engine Scopes","text":"Scope Maps To Description <code>detection</code> <code>src/atlas/core/detection.py</code> Project detection engine <code>scanner</code> <code>src/atlas/core/scanner.py</code> Config file parsing &amp; extraction <code>categories</code> <code>src/atlas/core/categories.py</code> Category contracts &amp; routing <code>modules</code> <code>src/atlas/core/modules.py</code> Module install/remove/update lifecycle <code>retrieve</code> <code>src/atlas/core/retrieve.py</code> Retrieve file building <code>prompts</code> <code>src/atlas/core/prompts.py</code> Dynamic prompt assembly <code>config</code> <code>src/atlas/core/config.py</code> Configuration hierarchy <code>structure</code> <code>src/atlas/core/structure.py</code> Project structure mapping <code>registry</code> <code>src/atlas/core/registry.py</code> Global module registry loading <code>system</code> <code>src/atlas/core/system.py</code> System tool detection <code>runner</code> <code>src/atlas/core/runner.py</code> Task execution (just verb) <code>git</code> <code>src/atlas/core/git.py</code> Git wrapper <code>platform</code> <code>src/atlas/core/platform.py</code> Platform CLI wrapper (gh, glab)"},{"location":"commit-rules/#top-level-scopes","title":"Top-Level Scopes","text":"Scope Maps To Description <code>server</code> <code>src/atlas/server.py</code> MCP server, tool definition, description <code>parser</code> <code>src/atlas/parser.py</code> Universal input parser <code>runtime</code> <code>src/atlas/runtime.py</code> Atlas class, lazy properties, verb routing <code>cli</code> <code>src/atlas/cli.py</code> CLI entry point"},{"location":"commit-rules/#infrastructure-scopes","title":"Infrastructure Scopes","text":"Scope Maps To Description <code>warehouse</code> <code>modules/</code> Module bundles and registry.json <code>tests</code> <code>tests/</code> Test suite (use when ONLY test files change) <code>docs</code> <code>*.md</code>, <code>CLAUDE.md</code> Documentation <code>build</code> <code>pyproject.toml</code>, <code>hatch*</code> Build &amp; packaging <code>ci</code> <code>.github/workflows/</code> GitHub Actions"},{"location":"commit-rules/#scope-selection-logic","title":"Scope Selection Logic","text":"Files Changed Strategy 1 file Most specific domain from the file path 2\u20133 files in same domain Common parent domain Source + matching tests Use source domain (not <code>tests</code>) &gt;3 unrelated domains Omit scope entirely"},{"location":"commit-rules/#banned-generic-scopes-never-use","title":"Banned Generic Scopes (NEVER use)","text":"<p><code>utils</code>, <code>common</code>, <code>helpers</code>, <code>misc</code>, <code>general</code>, <code>lib</code>, <code>shared</code>, <code>core</code> (use the specific sub-scope instead of <code>core</code>)</p>"},{"location":"commit-rules/#when-to-omit-scope","title":"When to Omit Scope","text":"<ul> <li>Changes span &gt;3 distinct scopes.</li> <li>Scope adds no information beyond the subject.</li> </ul>"},{"location":"commit-rules/#subject-rules","title":"SUBJECT RULES","text":"<ul> <li>Imperative mood: \"add\" not \"added\", \"fix\" not \"fixed\".</li> <li>Length: Target \u226450 chars. Hard limit \u226472 chars (including <code>type(scope):</code> prefix).</li> <li>Format: No period at end. Lowercase first letter (except proper nouns).</li> <li>Breaking: Add <code>!</code> after scope: <code>feat(runtime)!: require project path argument</code>.</li> <li>Specificity: A reviewer MUST be able to guess the diff from the subject alone.</li> <li>No emojis. No Gitmoji. Text only.</li> </ul>"},{"location":"commit-rules/#describe-what-not-how","title":"Describe WHAT, not HOW","text":"<ul> <li>\u274c <code>fix(scanner): add try/catch to TOML parser</code></li> <li> <p>\u2705 <code>fix(scanner): prevent crash on empty TOML sections</code></p> </li> <li> <p>\u274c <code>feat(modules): add install_module function</code></p> </li> <li>\u2705 <code>feat(modules): install module from warehouse with config enrichment</code></li> </ul>"},{"location":"commit-rules/#banned-filler-verbs-never-use-as-main-verb","title":"Banned Filler Verbs (NEVER use as main verb)","text":"<p><code>update</code>, <code>change</code>, <code>modify</code>, <code>improve</code>, <code>adjust</code>, <code>tweak</code>, <code>handle</code>, <code>ensure</code>, <code>address</code>, <code>fix up</code>, <code>work on</code></p> <p>\u2192 Use specific verbs: <code>add</code>, <code>remove</code>, <code>extract</code>, <code>validate</code>, <code>reject</code>, <code>enforce</code>, <code>replace</code>, <code>rename</code>, <code>cache</code>, <code>restrict</code>, <code>paginate</code>, <code>migrate</code>, <code>optimize</code>, <code>split</code>, <code>consolidate</code>, <code>serialize</code>, <code>throttle</code>, <code>configure</code>, <code>enable</code>, <code>disable</code>, <code>port</code>, <code>implement</code>, <code>expose</code>, <code>build</code>, <code>generate</code>.</p>"},{"location":"commit-rules/#body-rules","title":"BODY RULES","text":""},{"location":"commit-rules/#when-body-is-required","title":"When Body Is Required","text":"Condition Body? <code>feat</code>, <code>fix</code> REQUIRED (omit only for trivially obvious changes) <code>perf</code> REQUIRED (MUST include benchmark if available) Security-sensitive fix REQUIRED BREAKING CHANGE REQUIRED <code>refactor</code>, <code>build</code> Recommended <code>docs</code>, <code>style</code>, <code>test</code>, <code>ci</code>, <code>chore</code> Optional"},{"location":"commit-rules/#structure","title":"Structure","text":"<pre><code>&lt;WHY \u2014 motivation, bug cause, user impact&gt;\n\n- &lt;HOW \u2014 approach bullet 1&gt;\n- &lt;HOW \u2014 approach bullet 2&gt;\n- &lt;HOW \u2014 max 3 bullets&gt;\n</code></pre> <ul> <li>Wrap at 72 characters.</li> <li>Plain <code>-</code> bullets. No Markdown headers, bold, or links.</li> <li>One blank line between subject and body.</li> <li>One blank line between body and footers.</li> <li>Do NOT invent tickets, incidents, or benchmarks.</li> </ul>"},{"location":"commit-rules/#footer-rules","title":"FOOTER RULES","text":""},{"location":"commit-rules/#breaking-change","title":"Breaking Change","text":"<p><pre><code>BREAKING CHANGE: &lt;what changed, what breaks, migration path&gt;\n</code></pre> <code>!</code> in subject requires this footer. Footer requires <code>!</code>. Bidirectional.</p>"},{"location":"commit-rules/#issue-references-only-if-explicitly-provided-never-guess","title":"Issue References (only if explicitly provided \u2014 NEVER guess)","text":"<pre><code>Closes: #&lt;number&gt;\nFixes: #&lt;number&gt;\nRefs: #&lt;number&gt;\n</code></pre> <p>CRITICAL: Do NOT hallucinate issue numbers. If no issue number is visible in context, omit entirely.</p>"},{"location":"commit-rules/#security","title":"Security","text":"<pre><code>CVE: CVE-YYYY-NNNNN\nAdvisory: &lt;URL&gt;\n</code></pre>"},{"location":"commit-rules/#issue-workflow-rules","title":"ISSUE WORKFLOW RULES","text":"<p>These rules govern how to handle GitHub issues during development.</p>"},{"location":"commit-rules/#starting-an-issue","title":"Starting an Issue","text":"<ol> <li>Find the next open issue on the project board.</li> <li>Run: <code>gh issue edit &lt;number&gt; --add-label \"status:in-progress\" --repo Tomosius/atlas</code></li> <li>Update <code>CLAUDE.md</code> \u2014 set Current Issue to that issue number and title.</li> </ol>"},{"location":"commit-rules/#during-an-issue","title":"During an Issue","text":"<ul> <li>Commit as many times as needed. More commits is better than fewer.</li> <li>Each commit should reference the issue scope (not necessarily the number).</li> <li>Follow the atomic commit rules above strictly.</li> </ul>"},{"location":"commit-rules/#completing-an-issue","title":"Completing an Issue","text":"<p>When all work for an issue is done:</p> <ol> <li>Close the issue:    <pre><code>gh issue close &lt;number&gt; --repo Tomosius/atlas --comment \"Completed.\"\n</code></pre></li> <li>Remove in-progress label:    <pre><code>gh issue edit &lt;number&gt; --remove-label \"status:in-progress\" --repo Tomosius/atlas\n</code></pre></li> <li>Update <code>CLAUDE.md</code> \u2014 clear Current Issue, note it as completed.</li> <li>Open the next issue and mark it in-progress:    <pre><code>gh issue edit &lt;next-number&gt; --add-label \"status:in-progress\" --repo Tomosius/atlas\n</code></pre></li> <li>Update <code>CLAUDE.md</code> \u2014 set Current Issue to the new issue.</li> </ol>"},{"location":"commit-rules/#completing-a-milestone","title":"Completing a Milestone","text":"<p>When all issues in a milestone are closed:</p> <ol> <li>Determine the new version:</li> <li>Phase 1 ships \u2192 <code>0.1.0</code></li> <li>Phase 2 ships \u2192 <code>0.2.0</code></li> <li>Phase 3 ships \u2192 <code>0.3.0</code></li> <li>Phase 4 ships \u2192 <code>1.0.0</code></li> <li> <p>Patch releases within a phase \u2192 increment patch digit.</p> </li> <li> <p>Bump version in <code>pyproject.toml</code>:    <pre><code>[project]\nversion = \"0.2.0\"\n</code></pre></p> </li> <li> <p>Commit the bump:    <pre><code>chore(release): bump version to 0.2.0\n</code></pre></p> </li> <li> <p>Close the milestone on GitHub:    <pre><code>gh api repos/Tomosius/atlas/milestones/&lt;id&gt; -X PATCH -f state=closed\n</code></pre></p> </li> <li> <p>Update <code>CLAUDE.md</code> \u2014 note the completed milestone and current version.</p> </li> </ol>"},{"location":"commit-rules/#pre-output-verification-mandatory","title":"PRE-OUTPUT VERIFICATION (MANDATORY)","text":"<p>Before output, run ALL checks. If any fails, rewrite before outputting.</p> <ol> <li>Type: Highest valid match?</li> <li>Scope: Valid domain, \u226424 chars, lowercase, no extensions, not banned \u2014 or intentionally omitted?</li> <li>Subject verb: Banned verb? \u2192 Rewrite.</li> <li>Subject length: Full line (including prefix) \u226472 chars?</li> <li>Trailing punctuation: Subject must NOT end with <code>.</code> <code>...</code> <code>\u2026</code> <code>!</code> <code>?</code></li> <li>Atomicity: One logical change only?</li> <li>Body: Required for this type? WHY derived from diff?</li> <li>Breaking markers: <code>!</code> \u2194 <code>BREAKING CHANGE:</code> consistent?</li> <li>References: Issue numbers explicitly known, not guessed?</li> <li>Output only the final, passed version.</li> </ol>"},{"location":"commit-rules/#red-flags-checklist","title":"RED FLAGS CHECKLIST","text":"<p>Before finalizing, verify NONE of these are true:</p> <ul> <li> Subject describes two unrelated outcomes joined by \"and\" \u2192 Split.</li> <li> Subject uses a banned filler verb \u2192 Be specific.</li> <li> Subject exceeds 72 characters \u2192 Shorten.</li> <li> Subject ends with <code>.</code> <code>...</code> <code>\u2026</code> <code>!</code> <code>?</code> \u2192 Remove.</li> <li> Body just restates the diff \u2192 Explain WHY instead.</li> <li> Scope is a filename, extension, or folder name \u2192 Use the domain.</li> <li> Scope exceeds 24 characters \u2192 Shorten.</li> <li> Scope is <code>core</code> \u2192 Use specific sub-scope instead.</li> <li> Breaking <code>!</code> but no <code>BREAKING CHANGE:</code> footer \u2192 Add footer.</li> <li> Footer contains a guessed issue number \u2192 Remove.</li> </ul>"},{"location":"commit-rules/#special-patterns","title":"SPECIAL PATTERNS","text":"Pattern Format Dependency bump (both versions visible) <code>build(deps): bump &lt;pkg&gt; from &lt;old&gt; to &lt;new&gt;</code> Dependency bump (only new version visible) <code>build(deps): bump &lt;pkg&gt; to &lt;new&gt;</code> Dev dependency bump <code>build(deps-dev): bump &lt;pkg&gt; from &lt;old&gt; to &lt;new&gt;</code> Port from old codebase <code>feat(&lt;scope&gt;): port &lt;description&gt; from atlas-cli</code> Formatter-only <code>style: apply ruff formatting</code> Initial commit <code>feat: initialize project with &lt;framework&gt;</code> Version bump <code>chore(release): bump version to &lt;version&gt;</code> Revert <code>revert: &lt;original subject verbatim&gt;</code> (hash required)"},{"location":"commit-rules/#worked-examples-atlas-specific","title":"WORKED EXAMPLES (Atlas-Specific)","text":""},{"location":"commit-rules/#porting-a-module","title":"Porting a module","text":"<pre><code>feat(detection): port language markers and lock file tables from atlas-cli\n\nDetection relied on scattered conditionals. Porting the data\ntables enables parametrized testing and easier extension.\n\n- Port LANGUAGE_MARKERS dict (14 languages)\n- Port LOCK_FILE_MAP for package manager detection\n- Port FRAMEWORK_PATTERNS for framework identification\n</code></pre>"},{"location":"commit-rules/#adding-a-warehouse-module","title":"Adding a warehouse module","text":"<pre><code>feat(warehouse): add ruff module bundle with rules and config extraction\n\nAgents working on Python projects need ruff rule references\nand extracted config values to apply consistent formatting.\n\n- Add module.json with category, detect_files, conflicts_with\n- Write rules.md covering line-length, select, ignore conventions\n- Add config keys: line-length, select, ignore, extend-ignore\n</code></pre>"},{"location":"commit-rules/#fixing-a-scanner-bug","title":"Fixing a scanner bug","text":"<pre><code>fix(scanner): prevent crash on empty TOML sections\n\npyproject.toml files with empty [tool.ruff] sections caused\nKeyError in the TOML section parser, aborting the entire scan.\n\n- Guard section dict access with .get() before key extraction\n</code></pre>"},{"location":"commit-rules/#breaking-api-change","title":"Breaking API change","text":"<pre><code>feat(parser)!: require explicit verb for all atlas commands\n\nImplicit verb detection caused ambiguous routing when query\nstrings matched verb names. Explicit verbs make intent clear.\n\nBREAKING CHANGE: All atlas inputs must now start with a verb.\n\"ruff\" \u2192 \"retrieve ruff\". \"pytest --verbose\" \u2192 \"just pytest --verbose\".\n</code></pre>"},{"location":"commit-rules/#multiple-commits-for-one-issue-issue-30","title":"Multiple commits for one issue (Issue #30)","text":"<pre><code># Commit 1\nfeat(retrieve): add build_retrieve_file signature and file skeleton\n\n# Commit 2\nfeat(retrieve): inject extracted config values into rules.md placeholders\n\n# Commit 3\nfeat(retrieve): apply section filtering to narrow retrieve output\n\n# Commit 4\nfeat(retrieve): add freshness timestamp to retrieve file header\n\n# Commit 5\ntest(retrieve): add parametrized tests for value injection and filtering\n</code></pre>"},{"location":"commit-rules/#output-format","title":"OUTPUT FORMAT","text":""},{"location":"commit-rules/#chat-mode","title":"Chat Mode","text":"<p>Output ONLY the raw commit message. No introduction, no explanation, no Markdown fences, no quotation marks. Just the text starting with <code>type(scope): subject</code> or <code>type: subject</code>.</p> <p>Exception: If pre-output verification triggers a WARNING (non-atomic, truncated), output the WARNING instead of a commit message.</p>"},{"location":"commit-rules/#direct-commit-mode","title":"Direct-Commit Mode","text":"<p>Raw commit message text only. Never warnings. Abort on failure.</p>"},{"location":"development/","title":"Atlas MCP \u2014 Development Guide","text":"<p>Complete reference for the development workflow, toolchain, and coding standards.</p>"},{"location":"development/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Prerequisites</li> <li>First-time Setup</li> <li>Daily Workflow</li> <li>Task Runner (just)</li> <li>Toolchain Reference</li> <li>Coding Standards</li> <li>Docstring Style (Google)</li> <li>Testing Guide</li> <li>GitHub Issue Workflow</li> <li>CI Pipeline</li> </ol>"},{"location":"development/#1-prerequisites","title":"1. Prerequisites","text":"Tool Install Purpose <code>uv</code> <code>brew install uv</code> Python version + package manager <code>just</code> <code>brew install just</code> Task runner (like make, but better) <code>gh</code> <code>brew install gh</code> GitHub CLI for issue workflow Python 3.11+ managed by uv Runtime"},{"location":"development/#2-first-time-setup","title":"2. First-time Setup","text":"<pre><code>git clone https://github.com/Tomosius/atlas\ncd atlas\njust setup\n</code></pre> <p><code>just setup</code> does: 1. <code>uv sync --all-groups</code> \u2014 creates <code>.venv/</code>, installs all deps including dev tools 2. Prints toolchain versions to confirm everything is working</p> <p>You never need to activate the venv manually. All <code>just</code> commands use <code>uv run</code> which auto-discovers the venv.</p>"},{"location":"development/#3-daily-workflow","title":"3. Daily Workflow","text":"<pre><code># Before starting work \u2014 see what's in progress and what's next\njust issue-current\njust issue-next\n\n# Start an issue\njust issue-start 6\n\n# Write code, then get fast feedback\njust quick            # lint + ty (seconds)\n\n# Before committing\njust fmt              # auto-format\njust check            # full pipeline: fmt-check + lint + types + tests\n\n# After all checks pass \u2014 commit (follow COMMIT_RULES.md)\ngit add -p            # stage atomically\ngit commit            # write message per COMMIT_RULES.md\n\n# Close the issue when done\njust issue-done 6\n</code></pre>"},{"location":"development/#4-task-runner-just","title":"4. Task Runner (just)","text":"<p>Run <code>just</code> with no arguments to see all available recipes.</p>"},{"location":"development/#setup","title":"Setup","text":"Command Description <code>just setup</code> Install deps, print toolchain info <code>just info</code> Show tool versions and project info"},{"location":"development/#formatting","title":"Formatting","text":"Command Description <code>just fmt</code> Format all files with ruff (apply) <code>just fmt-check</code> Check formatting without changing files (used in CI)"},{"location":"development/#linting","title":"Linting","text":"Command Description <code>just lint</code> Run ruff linter (includes docstring checks) <code>just lint-fix</code> Run ruff linter and auto-fix safe issues"},{"location":"development/#type-checking","title":"Type Checking","text":"Command Description <code>just ty</code> Fast check with <code>ty</code> (use during development) <code>just pyright</code> Thorough check with <code>basedpyright</code> (use before push) <code>just types</code> Run both type checkers"},{"location":"development/#testing","title":"Testing","text":"Command Description <code>just test</code> Run all tests <code>just test-v</code> Run all tests, verbose output <code>just test-unit</code> Run only <code>@pytest.mark.unit</code> tests <code>just test-integration</code> Run only <code>@pytest.mark.integration</code> tests <code>just test-k \"pattern\"</code> Run tests matching a keyword <code>just test-f tests/test_scanner.py</code> Run a specific file <code>just test-cov</code> Run tests with HTML coverage report <code>just test-watch</code> Re-run tests on file changes"},{"location":"development/#quality-gates","title":"Quality Gates","text":"Command Description <code>just check</code> Full pipeline \u2014 mirrors CI exactly <code>just quick</code> Fast check \u2014 lint + ty only (no tests)"},{"location":"development/#running-atlas","title":"Running Atlas","text":"Command Description <code>just run status</code> Run atlas CLI with arguments <code>just serve</code> Start the MCP server (stdio transport) <code>just repl</code> Python REPL with atlas importable"},{"location":"development/#issue-workflow","title":"Issue Workflow","text":"Command Description <code>just issue-current</code> Show in-progress issues <code>just issue-next</code> Show next open Phase 1 issues <code>just issue-start 6</code> Mark issue #6 as in-progress <code>just issue-done 6</code> Close issue #6"},{"location":"development/#build","title":"Build","text":"Command Description <code>just build</code> Build wheel + sdist <code>just publish-test</code> Publish to TestPyPI <code>just publish</code> Publish to PyPI <code>just clean</code> Remove build artifacts, <code>__pycache__</code>, <code>.coverage</code>"},{"location":"development/#5-toolchain-reference","title":"5. Toolchain Reference","text":""},{"location":"development/#uv","title":"uv","text":"<p>Fast Python package manager from Astral. Manages the venv at <code>.venv/</code>.</p> <pre><code>uv sync --all-groups        # install all deps (including dev)\nuv add &lt;package&gt;            # add runtime dependency\nuv add --dev &lt;package&gt;      # add dev dependency\nuv remove &lt;package&gt;         # remove dependency\nuv run &lt;command&gt;            # run command inside venv\nuv build                    # build wheel + sdist\nuv publish                  # publish to PyPI\n</code></pre>"},{"location":"development/#ruff","title":"ruff","text":"<p>Linter + formatter. Replaces flake8, black, isort, pydocstyle.</p> <pre><code>just lint                   # check for issues\njust lint-fix               # fix safe issues automatically\njust fmt                    # format files\njust fmt-check              # check format (CI mode)\n\n# Direct usage if needed\nuv run ruff check src/ tests/ --fix\nuv run ruff format src/ tests/\n</code></pre> <p>Config in <code>pyproject.toml</code> under <code>[tool.ruff]</code>. Key settings: - <code>line-length = 120</code> - <code>target-version = \"py310\"</code> - Google docstring convention (<code>D</code> rules) - Import sorting (<code>I</code> rules)</p>"},{"location":"development/#ty","title":"ty","text":"<p>Fast type checker from Astral (same team as ruff/uv). Experimental but very fast. Use for quick feedback during development.</p> <pre><code>just ty\nuv run ty check src/\n</code></pre>"},{"location":"development/#basedpyright","title":"basedpyright","text":"<p>Thorough type checker, stricter than vanilla pyright. Used as the CI gate.</p> <pre><code>just pyright\nuv run basedpyright src/\n</code></pre> <p>Config in <code>pyproject.toml</code> under <code>[tool.basedpyright]</code>. Currently set to <code>typeCheckingMode = \"standard\"</code> with some rules relaxed (the result-dict pattern creates many \"unknown type\" warnings that are intentional).</p>"},{"location":"development/#pytest","title":"pytest","text":"<p>Test runner.</p> <pre><code>just test                   # all tests\njust test-v                 # verbose\njust test-k \"detection\"     # filter by keyword\njust test-cov               # with coverage\n</code></pre> <p>Config in <code>pyproject.toml</code> under <code>[tool.pytest.ini_options]</code>: - <code>testpaths = [\"tests\"]</code> - <code>pythonpath = [\"src\"]</code> \u2014 lets tests import <code>atlas</code> directly - <code>asyncio_mode = \"auto\"</code> \u2014 async tests work without decorator - Default flags: <code>-ra -q --tb=short</code></p>"},{"location":"development/#6-coding-standards","title":"6. Coding Standards","text":""},{"location":"development/#language-version","title":"Language version","text":"<p>Target Python 3.10+. Use <code>|</code> union syntax only where safe; ruff's <code>UP007</code> rule is ignored to avoid false positives.</p>"},{"location":"development/#result-pattern-no-exceptions-in-core","title":"Result pattern (no exceptions in core)","text":"<p>The core engine never raises exceptions for expected error conditions. It returns result dicts:</p> <pre><code># Good\ndef find_module(name: str) -&gt; dict:\n    if name not in registry:\n        return {\"ok\": False, \"error\": \"MODULE_NOT_FOUND\", \"module\": name}\n    return {\"ok\": True, \"data\": registry[name]}\n\n# Bad \u2014 don't raise in core\ndef find_module(name: str) -&gt; dict:\n    if name not in registry:\n        raise KeyError(f\"Module {name} not found\")   # \u274c\n</code></pre> <p>Only <code>server.py</code> (MCP layer) and <code>cli.py</code> may raise or catch exceptions.</p>"},{"location":"development/#no-global-state-in-core","title":"No global state in core","text":"<p>All functions take explicit arguments. No module-level mutable state.</p> <pre><code># Good\ndef detect_project(path: Path, config: AtlasConfig) -&gt; ProjectDetection: ...\n\n# Bad\n_current_path: Path | None = None   # \u274c global state\n</code></pre>"},{"location":"development/#stdlib-only-core","title":"stdlib-only core","text":"<p><code>src/atlas/core/</code> must not import anything outside the standard library. Only <code>src/atlas/server.py</code> may import <code>mcp</code>.</p>"},{"location":"development/#data-tables-over-code-branches","title":"Data tables over code branches","text":"<p>Detection, scanning, and routing use dicts and lists \u2014 not if/elif chains.</p> <pre><code># Good\nLANGUAGE_MARKERS: dict[str, list[str]] = {\n    \"python\": [\"pyproject.toml\", \"setup.py\", \"requirements.txt\"],\n    \"typescript\": [\"tsconfig.json\", \"package.json\"],\n}\n\n# Bad\ndef detect_language(files):       # \u274c\n    if \"pyproject.toml\" in files:\n        return \"python\"\n    elif \"tsconfig.json\" in files:\n        return \"typescript\"\n</code></pre>"},{"location":"development/#pre-compute-then-read","title":"Pre-compute then read","text":"<p>Retrieve files are built at <code>init</code>/<code>add</code>/<code>sync</code> time and stored on disk. The MCP tool reads them as instant file reads \u2014 no computation at serve time.</p>"},{"location":"development/#import-style","title":"Import style","text":"<pre><code># Standard library first, then third-party, then local \u2014 ruff enforces this\nfrom __future__ import annotations\n\nimport json\nimport subprocess\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from collections.abc import Iterator\n</code></pre>"},{"location":"development/#7-docstring-style-google","title":"7. Docstring Style (Google)","text":"<p>All public functions, classes, and methods require Google-style docstrings. Ruff rule <code>D</code> enforces this. Tests are exempt.</p>"},{"location":"development/#function-docstring","title":"Function docstring","text":"<pre><code>def scan_module_config(module_name: str, project_path: Path) -&gt; dict:\n    \"\"\"Scan project config files for values relevant to a module.\n\n    Reads config files listed in MODULE_CONFIG_MAP for the given module,\n    extracts key-value pairs, and returns them for injection into rules.md.\n\n    Args:\n        module_name: The module identifier (e.g. \"ruff\", \"pytest\").\n        project_path: Absolute path to the project root.\n\n    Returns:\n        A result dict with shape:\n            {\"ok\": True, \"data\": {\"line-length\": \"120\", \"select\": \"E,W,F\"}}\n        or on failure:\n            {\"ok\": False, \"error\": \"CONFIG_NOT_FOUND\", \"module\": module_name}\n\n    Raises:\n        Does not raise. All errors returned as result dicts.\n\n    Example:\n        &gt;&gt;&gt; result = scan_module_config(\"ruff\", Path(\"/my/project\"))\n        &gt;&gt;&gt; if result[\"ok\"]:\n        ...     print(result[\"data\"][\"line-length\"])\n        120\n    \"\"\"\n</code></pre>"},{"location":"development/#class-docstring","title":"Class docstring","text":"<pre><code>class Atlas:\n    \"\"\"Main runtime class. Owns all project state for a single project root.\n\n    Uses lazy properties backed by cached JSON files in .atlas/. Call\n    invalidate() after any mutation to clear the cache.\n\n    Attributes:\n        project_path: Absolute path to the project root.\n        atlas_dir: Path to the .atlas/ directory inside the project.\n\n    Example:\n        &gt;&gt;&gt; atlas = Atlas(Path(\"/my/project\"))\n        &gt;&gt;&gt; result = atlas.handle(\"retrieve python\")\n        &gt;&gt;&gt; print(result[\"data\"])\n    \"\"\"\n</code></pre>"},{"location":"development/#short-docstring-one-liner","title":"Short docstring (one-liner)","text":"<pre><code>def ok_result(data: dict) -&gt; dict:\n    \"\"\"Wrap data in a standard success result dict.\"\"\"\n    return {\"ok\": True, \"data\": data}\n</code></pre>"},{"location":"development/#when-to-skip-a-docstring","title":"When to skip a docstring","text":"<ul> <li><code>__init__</code> methods (document on the class instead) \u2014 <code>D107</code> ignored</li> <li>Test functions \u2014 <code>D</code> rules ignored in <code>tests/</code></li> <li>Private helpers (<code>_name</code>) that are obvious from context \u2014 not required   but still appreciated</li> </ul>"},{"location":"development/#8-testing-guide","title":"8. Testing Guide","text":""},{"location":"development/#structure","title":"Structure","text":"<pre><code>tests/\n  conftest.py              # shared fixtures (project paths, tmp dirs)\n  fixtures/\n    python_project/        # fake Python project with pyproject.toml + ruff\n    typescript_project/    # fake TS project with package.json + tsconfig\n    empty_project/         # bare directory\n  test_detection.py\n  test_scanner.py\n  test_categories.py\n  test_modules.py\n  test_retrieve.py\n  test_parser.py\n  test_runtime.py\n  test_server.py\n  test_cli.py\n</code></pre>"},{"location":"development/#fixture-projects","title":"Fixture projects","text":"<p>Tests that need a real project on disk use the fixtures in <code>tests/fixtures/</code>. Access them via conftest fixtures:</p> <pre><code>@pytest.fixture\ndef python_project(tmp_path):\n    \"\"\"Copy the python fixture to a tmp dir and return its path.\"\"\"\n    src = Path(__file__).parent / \"fixtures\" / \"python_project\"\n    dst = tmp_path / \"python_project\"\n    shutil.copytree(src, dst)\n    return dst\n</code></pre>"},{"location":"development/#markers","title":"Markers","text":"<pre><code>@pytest.mark.unit          # fast, no filesystem, no subprocess\n@pytest.mark.integration   # needs real filesystem / subprocess\n@pytest.mark.slow          # &gt; 1s (deselect with -m \"not slow\")\n</code></pre>"},{"location":"development/#parametrize-for-data-tables","title":"Parametrize for data tables","text":"<p>Detection and scanner tests use <code>@pytest.mark.parametrize</code> to cover all entries in the data tables without repetition:</p> <pre><code>@pytest.mark.parametrize(\"language,marker\", [\n    (\"python\", \"pyproject.toml\"),\n    (\"typescript\", \"tsconfig.json\"),\n    (\"rust\", \"Cargo.toml\"),\n])\n@pytest.mark.unit\ndef test_detect_language_from_marker(language, marker, tmp_path):\n    (tmp_path / marker).touch()\n    result = detect_project(tmp_path)\n    assert result[\"ok\"]\n    assert result[\"data\"].language == language\n</code></pre>"},{"location":"development/#async-tests","title":"Async tests","text":"<p><code>asyncio_mode = \"auto\"</code> is set \u2014 async test functions just work:</p> <pre><code>async def test_server_tool_listing():\n    result = await list_tools()\n    assert len(result) == 1\n    assert result[0].name == \"atlas\"\n</code></pre>"},{"location":"development/#9-github-issue-workflow","title":"9. GitHub Issue Workflow","text":"<p>See <code>COMMIT_RULES.md</code> for the full protocol. Quick reference:</p> <pre><code># See what to work on\njust issue-current          # in-progress\njust issue-next             # next open Phase 1 issues\n\n# Start\njust issue-start 6\n# \u2192 update CLAUDE.md Current Issue\n\n# Work \u2014 many atomic commits per issue is correct\njust quick                  # fast check after each logical step\njust fmt &amp;&amp; git add -p &amp;&amp; git commit\n\n# Finish\njust check                  # full pipeline must pass\njust issue-done 6\n# \u2192 update CLAUDE.md Current Issue to next\n</code></pre>"},{"location":"development/#10-ci-pipeline","title":"10. CI Pipeline","text":"<p>Defined in <code>.github/workflows/ci.yml</code>. Runs on push/PR to <code>main</code> and <code>dev</code>.</p>"},{"location":"development/#jobs","title":"Jobs","text":"<p>quality \u2014 runs on Python 3.11, 3.12, 3.13: 1. <code>uv sync --all-groups</code> 2. <code>ruff check src/ tests/</code> \u2014 lint 3. <code>ruff format --check src/ tests/</code> \u2014 format gate 4. <code>basedpyright src/</code> \u2014 type check 5. <code>pytest tests/ -v --tb=short</code> \u2014 tests</p> <p>publish \u2014 runs only on <code>v*</code> tags, after quality passes: 1. <code>uv build</code> 2. Publishes to PyPI via trusted publishing (no token needed)</p>"},{"location":"development/#matching-ci-locally","title":"Matching CI locally","text":"<pre><code>just check\n</code></pre> <p>This runs exactly the same steps as CI. If <code>just check</code> passes locally, CI will pass.</p>"},{"location":"development/#pypi-publishing","title":"PyPI publishing","text":"<p>Publishing uses GitHub's OIDC trusted publishing \u2014 no API token stored in secrets. To release:</p> <pre><code># 1. Bump version in pyproject.toml\n# 2. Commit: chore(release): bump version to 0.1.0\n# 3. Tag and push\ngit tag v0.1.0\ngit push origin v0.1.0\n# CI publishes automatically\n</code></pre>"},{"location":"api/categories/","title":"atlas.core.categories","text":""},{"location":"api/categories/#atlas.core.categories","title":"atlas.core.categories","text":"<p>Category contracts and router for Atlas modules.</p>"},{"location":"api/categories/#atlas.core.categories.CategoryRouter","title":"CategoryRouter","text":"<pre><code>CategoryRouter(manifest: dict, registry: dict)\n</code></pre> <p>Query interface for finding installed modules by category or command.</p> <p>Used by the MCP server and runtime to determine which verbs and tools are available given the current project's installed modules.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def __init__(self, manifest: dict, registry: dict) -&gt; None:\n    self._manifest = manifest\n    self._registry = registry\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.CategoryRouter.has_category_installed","title":"has_category_installed","text":"<pre><code>has_category_installed(category: str) -&gt; bool\n</code></pre> <p>Return True if at least one installed module belongs to category.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def has_category_installed(self, category: str) -&gt; bool:\n    \"\"\"Return True if at least one installed module belongs to *category*.\"\"\"\n    installed = self._manifest.get(\"installed_modules\", {})\n    return any(info.get(\"category\") == category for info in installed.values())\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.CategoryRouter.find_all_with_command","title":"find_all_with_command","text":"<pre><code>find_all_with_command(command: str) -&gt; list[dict]\n</code></pre> <p>Return every installed module that exposes command.</p> <p>Each entry is <code>{\"module\": &lt;name&gt;, \"command\": &lt;cmd_string&gt;}</code>.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def find_all_with_command(self, command: str) -&gt; list[dict]:\n    \"\"\"Return every installed module that exposes *command*.\n\n    Each entry is ``{\"module\": &lt;name&gt;, \"command\": &lt;cmd_string&gt;}``.\n    \"\"\"\n    installed = self._manifest.get(\"installed_modules\", {})\n    modules = self._registry.get(\"modules\", {})\n    results = []\n    for name in installed:\n        reg = modules.get(name, {})\n        commands = reg.get(\"commands\", {})\n        if command in commands:\n            results.append({\"module\": name, \"command\": commands[command]})\n    return results\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.CategoryRouter.find_module_for_category","title":"find_module_for_category","text":"<pre><code>find_module_for_category(category: str) -&gt; str | None\n</code></pre> <p>Return the first installed module name for category, or None.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def find_module_for_category(self, category: str) -&gt; str | None:\n    \"\"\"Return the first installed module name for *category*, or None.\"\"\"\n    installed = self._manifest.get(\"installed_modules\", {})\n    for name, info in installed.items():\n        if info.get(\"category\") == category:\n            return name\n    return None\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.get_valid_categories","title":"get_valid_categories","text":"<pre><code>get_valid_categories() -&gt; list[str]\n</code></pre> <p>Return all valid category names (installable + auto).</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def get_valid_categories() -&gt; list[str]:\n    \"\"\"Return all valid category names (installable + auto).\"\"\"\n    return list(ALL_CATEGORIES.keys())\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.is_valid_category","title":"is_valid_category","text":"<pre><code>is_valid_category(category: str) -&gt; bool\n</code></pre> <p>Return True if category is a recognised Atlas category.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def is_valid_category(category: str) -&gt; bool:\n    \"\"\"Return True if *category* is a recognised Atlas category.\"\"\"\n    return category in ALL_CATEGORIES\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.is_auto_category","title":"is_auto_category","text":"<pre><code>is_auto_category(category: str) -&gt; bool\n</code></pre> <p>Return True if category is an auto-generated (non-installable) category.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def is_auto_category(category: str) -&gt; bool:\n    \"\"\"Return True if *category* is an auto-generated (non-installable) category.\"\"\"\n    return category in AUTO_CATEGORIES\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.get_contract","title":"get_contract","text":"<pre><code>get_contract(category: str) -&gt; dict\n</code></pre> <p>Return the full contract dict for category, or {} if unknown.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def get_contract(category: str) -&gt; dict:\n    \"\"\"Return the full contract dict for *category*, or {} if unknown.\"\"\"\n    return ALL_CATEGORIES.get(category, {})\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.get_required_fields","title":"get_required_fields","text":"<pre><code>get_required_fields(category: str) -&gt; list[str]\n</code></pre> <p>Return the list of required module fields for category.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def get_required_fields(category: str) -&gt; list[str]:\n    \"\"\"Return the list of required module fields for *category*.\"\"\"\n    return ALL_CATEGORIES.get(category, {}).get(\"required_fields\", [])\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.get_expected_commands","title":"get_expected_commands","text":"<pre><code>get_expected_commands(category: str) -&gt; list[str]\n</code></pre> <p>Return the list of expected command keys for category.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def get_expected_commands(category: str) -&gt; list[str]:\n    \"\"\"Return the list of expected command keys for *category*.\"\"\"\n    return ALL_CATEGORIES.get(category, {}).get(\"expected_commands\", [])\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.validate_module_against_contract","title":"validate_module_against_contract","text":"<pre><code>validate_module_against_contract(\n    module_name: str, reg_entry: dict\n) -&gt; list[dict]\n</code></pre> <p>Validate reg_entry against its category's contract.</p> <p>Returns a list of error dicts <code>{\"module\": module_name, \"error\": message}</code>. An empty list means the module is valid.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def validate_module_against_contract(module_name: str, reg_entry: dict) -&gt; list[dict]:\n    \"\"\"Validate *reg_entry* against its category's contract.\n\n    Returns a list of error dicts ``{\"module\": module_name, \"error\": message}``.\n    An empty list means the module is valid.\n    \"\"\"\n    errors: list[dict] = []\n\n    category = reg_entry.get(\"category\", \"\")\n    contract = ALL_CATEGORIES.get(category)\n\n    if contract is None:\n        errors.append(\n            {\n                \"module\": module_name,\n                \"error\": f\"unknown category: {category!r}\",\n            }\n        )\n        return errors  # can't validate further without a contract\n\n    # Check required fields\n    for field in contract.get(\"required_fields\", []):\n        if field not in reg_entry:\n            errors.append(\n                {\n                    \"module\": module_name,\n                    \"error\": f\"missing required field: {field!r}\",\n                }\n            )\n\n    # Check expected commands\n    commands_val = reg_entry.get(\"commands\", {})\n    commands = commands_val if isinstance(commands_val, dict) else {}\n    for cmd in contract.get(\"expected_commands\", []):\n        if cmd not in commands:\n            errors.append(\n                {\n                    \"module\": module_name,\n                    \"error\": f\"missing expected command: {cmd!r}\",\n                }\n            )\n\n    return errors\n</code></pre>"},{"location":"api/categories/#atlas.core.categories.validate_registry_integrity","title":"validate_registry_integrity","text":"<pre><code>validate_registry_integrity(registry: dict) -&gt; list[dict]\n</code></pre> <p>Validate every module in registry against its category contract.</p> <p>registry is expected to be <code>{\"modules\": {name: entry, ...}}</code>.</p> <p>Returns a flat list of error dicts across all modules. An empty list means the entire registry is valid.</p> Source code in <code>src/atlas/core/categories.py</code> <pre><code>def validate_registry_integrity(registry: dict) -&gt; list[dict]:\n    \"\"\"Validate every module in *registry* against its category contract.\n\n    *registry* is expected to be ``{\"modules\": {name: entry, ...}}``.\n\n    Returns a flat list of error dicts across all modules.\n    An empty list means the entire registry is valid.\n    \"\"\"\n    errors: list[dict] = []\n    modules = registry.get(\"modules\", {})\n    for name, entry in modules.items():\n        errors.extend(validate_module_against_contract(name, entry))\n    return errors\n</code></pre>"},{"location":"api/cli/","title":"atlas.cli","text":""},{"location":"api/cli/#atlas.cli","title":"atlas.cli","text":"<p>Atlas CLI \u2014 thin wrapper around the Atlas runtime.</p> <p>Provides a terminal interface that mirrors the MCP tool's single-string input model.  All routing goes through the same Atlas runtime class used by the MCP server.</p> Usage <p>atlas         # e.g. \"atlas python\", \"atlas init\", \"atlas add ruff\" atlas                # prints current status / help</p>"},{"location":"api/cli/#atlas.cli.run","title":"run","text":"<pre><code>run(raw: str, project_dir: str | None = None) -&gt; int\n</code></pre> <p>Parse raw, route to Atlas, print the result.</p> <p>Returns 0 on success, 1 on error.</p> Source code in <code>src/atlas/cli.py</code> <pre><code>def run(raw: str, project_dir: str | None = None) -&gt; int:\n    \"\"\"Parse *raw*, route to Atlas, print the result.\n\n    Returns 0 on success, 1 on error.\n    \"\"\"\n    atlas = Atlas(project_dir)\n    parsed = parse_input(raw)\n\n    if parsed.verb is None:\n        result = atlas.query(parsed.contexts, parsed.message)\n    elif parsed.verb == \"init\":\n        result = atlas.init(parsed.args)\n    elif parsed.verb == \"add\":\n        result = atlas.add_modules(parsed.args)\n    elif parsed.verb in (\"create\", \"edit\", \"remove\") and parsed.resource_type:\n        result = atlas.manage_resource(parsed.verb, parsed.resource_type, parsed.args)\n    elif parsed.verb == \"remove\":\n        result = atlas.remove_module(parsed.args[0] if parsed.args else \"\")\n    elif parsed.verb == \"list\":\n        result = atlas.list_resources(parsed.args[0] if parsed.args else \"all\")\n    elif parsed.verb == \"just\":\n        result = atlas.just(\n            parsed.args[0] if parsed.args else \"\",\n            parsed.args[1:],\n        )\n    elif parsed.verb == \"vcs\":\n        result = atlas.vcs(parsed.args)\n    elif parsed.verb == \"crud\":\n        result = atlas.crud(parsed.args)\n    elif parsed.verb == \"sync\":\n        result = atlas.sync(parsed.args)\n    else:\n        result = error_result(\"INVALID_ARGUMENT\", f\"Unknown verb: {parsed.verb}\")\n\n    _print_result(result)\n\n    if isinstance(result, dict) and result.get(\"ok\") is False:\n        return 1\n    return 0\n</code></pre>"},{"location":"api/cli/#atlas.cli.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Console script entry point: <code>atlas</code>.</p> Source code in <code>src/atlas/cli.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Console script entry point: ``atlas``.\"\"\"\n    # Join all CLI arguments as a single space-separated string,\n    # matching the MCP tool's single-string-input model.\n    raw = \" \".join(sys.argv[1:])\n    sys.exit(run(raw))\n</code></pre>"},{"location":"api/config/","title":"atlas.core.config","text":""},{"location":"api/config/#atlas.core.config","title":"atlas.core.config","text":"<p>Configuration hierarchy: project .atlas/config.json &gt; global ~/.atlas/config.json &gt; defaults.</p>"},{"location":"api/config/#atlas.core.config.AtlasConfig","title":"AtlasConfig  <code>dataclass</code>","text":"<pre><code>AtlasConfig(\n    retrieve_links: dict[str, list[str]] = dict(),\n    ignore_patterns: list[str] = list(),\n    detection_overrides: dict[str, str] = dict(),\n    package_manager_override: str = \"\",\n    auto_add_recommendations: bool = False,\n)\n</code></pre> <p>Atlas configuration with three-level hierarchy.</p>"},{"location":"api/config/#atlas.core.config.load_config","title":"load_config","text":"<pre><code>load_config(project_dir: str = '.') -&gt; AtlasConfig\n</code></pre> <p>Load config with hierarchy: project &gt; global &gt; defaults.</p> Source code in <code>src/atlas/core/config.py</code> <pre><code>def load_config(project_dir: str = \".\") -&gt; AtlasConfig:\n    \"\"\"Load config with hierarchy: project &gt; global &gt; defaults.\"\"\"\n    config = AtlasConfig()\n\n    # Global config (~/.atlas/config.json)\n    global_path = os.path.expanduser(\"~/.atlas/config.json\")\n    if os.path.isfile(global_path):\n        _merge_config(config, _load_json(global_path))\n\n    # Project config (.atlas/config.json)\n    project_config = os.path.join(os.path.abspath(project_dir), \".atlas\", \"config.json\")\n    if os.path.isfile(project_config):\n        _merge_config(config, _load_json(project_config))\n\n    return config\n</code></pre>"},{"location":"api/config/#atlas.core.config.save_config","title":"save_config","text":"<pre><code>save_config(data: dict, path: str) -&gt; None\n</code></pre> <p>Save config dict to JSON file.</p> Source code in <code>src/atlas/core/config.py</code> <pre><code>def save_config(data: dict, path: str) -&gt; None:\n    \"\"\"Save config dict to JSON file.\"\"\"\n    os.makedirs(os.path.dirname(path), exist_ok=True)\n    with open(path, \"w\") as f:\n        json.dump(data, f, indent=2, ensure_ascii=False)\n        f.write(\"\\n\")\n</code></pre>"},{"location":"api/detection/","title":"atlas.core.detection","text":""},{"location":"api/detection/#atlas.core.detection","title":"atlas.core.detection","text":"<p>Language, framework, and database detection engine.</p>"},{"location":"api/detection/#atlas.core.detection.detect_project","title":"detect_project","text":"<pre><code>detect_project(project_dir: str) -&gt; ProjectDetection\n</code></pre> <p>Run full project detection and return a ProjectDetection result.</p> <p>Parameters:</p> Name Type Description Default <code>project_dir</code> <code>str</code> <p>Absolute or relative path to the project root.</p> required <p>Returns:</p> Type Description <code>ProjectDetection</code> <p>Populated ProjectDetection dataclass.</p> Source code in <code>src/atlas/core/detection.py</code> <pre><code>def detect_project(project_dir: str) -&gt; ProjectDetection:\n    \"\"\"Run full project detection and return a ProjectDetection result.\n\n    Args:\n        project_dir: Absolute or relative path to the project root.\n\n    Returns:\n        Populated ProjectDetection dataclass.\n    \"\"\"\n    project_dir = os.path.abspath(project_dir)\n\n    if not os.path.isdir(project_dir):\n        return ProjectDetection()\n\n    languages, primary = _detect_languages(project_dir)\n    package_manager = _detect_package_manager(project_dir, languages)\n    existing_tools = _detect_existing_tools(project_dir)\n    frameworks, stack = _detect_frameworks_and_stack(project_dir, languages)\n    databases = _detect_databases(project_dir, languages)\n    infrastructure = _detect_infrastructure(project_dir)\n    structure_type, workspace_manager = _detect_structure(project_dir)\n\n    return ProjectDetection(\n        languages=languages,\n        primary_language=primary,\n        package_manager=package_manager,\n        existing_tools=existing_tools,\n        frameworks=frameworks,\n        stack=stack,\n        databases=databases,\n        infrastructure=infrastructure,\n        structure_type=structure_type,\n        workspace_manager=workspace_manager,\n        system_tools=detect_system_tools(),\n    )\n</code></pre>"},{"location":"api/modules/","title":"atlas.core.modules","text":""},{"location":"api/modules/#atlas.core.modules","title":"atlas.core.modules","text":"<p>Module lifecycle management \u2014 install, remove, update.</p>"},{"location":"api/modules/#atlas.core.modules.resolve_pkg_variables","title":"resolve_pkg_variables","text":"<pre><code>resolve_pkg_variables(\n    text: str, package_manager: str\n) -&gt; str\n</code></pre> <p>Replace <code>{{pkg_run}}</code>, <code>{{pkg_add}}</code>, <code>{{pkg_add_dev}}</code>, and <code>{{pkg_sync}}</code> in text with the concrete commands for package_manager.</p> <p>Falls back to the <code>pip</code> template when package_manager is unknown. Unknown placeholder tokens are left unchanged.</p> Source code in <code>src/atlas/core/modules.py</code> <pre><code>def resolve_pkg_variables(text: str, package_manager: str) -&gt; str:\n    \"\"\"Replace ``{{pkg_run}}``, ``{{pkg_add}}``, ``{{pkg_add_dev}}``,\n    and ``{{pkg_sync}}`` in *text* with the concrete commands for\n    *package_manager*.\n\n    Falls back to the ``pip`` template when *package_manager* is unknown.\n    Unknown placeholder tokens are left unchanged.\n    \"\"\"\n    variables = PKG_VARIABLES.get(package_manager, PKG_VARIABLES[\"pip\"])\n    for var_name, replacement in variables.items():\n        text = text.replace(\"{{\" + var_name + \"}}\", replacement)\n    return text\n</code></pre>"},{"location":"api/modules/#atlas.core.modules.install_module","title":"install_module","text":"<pre><code>install_module(\n    module_name: str,\n    registry: dict,\n    warehouse_dir: str,\n    atlas_dir: str,\n    manifest: dict,\n    package_manager: str = \"\",\n) -&gt; dict\n</code></pre> <p>Install a module from the warehouse into the project.</p> <p>Steps: 1. Validate \u2014 exists in registry, not already installed, no conflicts. 2. Load bundle from warehouse (<code>module.json</code>). 3. Scan project config to extract current values. 4. Enrich rules with extracted values. 5. Resolve package manager variables in commands. 6. Write to <code>.atlas/modules/&lt;name&gt;.json</code>. 7. Update manifest in-place.</p> <p>Returns <code>ok_result(installed=name, warnings=[])</code> on success, or an <code>error_result</code> on the first validation failure.</p> Source code in <code>src/atlas/core/modules.py</code> <pre><code>def install_module(\n    module_name: str,\n    registry: dict,\n    warehouse_dir: str,\n    atlas_dir: str,\n    manifest: dict,\n    package_manager: str = \"\",\n) -&gt; dict:\n    \"\"\"Install a module from the warehouse into the project.\n\n    Steps:\n    1. Validate \u2014 exists in registry, not already installed, no conflicts.\n    2. Load bundle from warehouse (``module.json``).\n    3. Scan project config to extract current values.\n    4. Enrich rules with extracted values.\n    5. Resolve package manager variables in commands.\n    6. Write to ``.atlas/modules/&lt;name&gt;.json``.\n    7. Update manifest in-place.\n\n    Returns ``ok_result(installed=name, warnings=[])`` on success,\n    or an ``error_result`` on the first validation failure.\n    \"\"\"\n    # 1. Validate\n    installed = list(manifest.get(\"installed_modules\", {}).keys())\n\n    reg_entry = find_module(registry, module_name)\n    if not reg_entry:\n        return error_result(\"MODULE_NOT_FOUND\", module_name)\n\n    if module_name in installed:\n        return error_result(\"MODULE_ALREADY_INSTALLED\", module_name)\n\n    conflicts = check_conflicts(registry, module_name, installed)\n    if conflicts:\n        return error_result(\n            \"MODULE_CONFLICT\",\n            f\"{module_name} conflicts with {', '.join(conflicts)}\",\n        )\n\n    # 2. Load bundle \u2014 fall back to a minimal dict when warehouse has no file.\n    bundle = load_module_bundle(module_name, registry, warehouse_dir)\n    if not bundle:\n        bundle = {\n            \"id\": module_name,\n            \"category\": reg_entry.get(\"category\", \"\"),\n            \"version\": reg_entry.get(\"version\", \"1.0.0\"),\n        }\n\n    # 3. Scan project config for extracted values.\n    project_dir = os.path.dirname(os.path.abspath(atlas_dir))\n    scan_result = scan_module_config(module_name, project_dir)\n\n    # 4. Enrich \u2014 merge extracted config values into the bundle copy.\n    rules = dict(bundle)\n    if scan_result.get(\"found\"):\n        rules[\"config_file\"] = scan_result.get(\"config_file\", \"\")\n        rules[\"config_section\"] = scan_result.get(\"config_section\", \"\")\n        extracted = scan_result.get(\"extracted\", {})\n        if extracted:\n            rules.setdefault(\"rules\", {}).update(extracted)\n\n    # 5. Resolve package manager variables in every command string.\n    if package_manager:\n        commands = rules.get(\"commands\", {})\n        if commands:\n            rules[\"commands\"] = {\n                cmd_name: resolve_pkg_variables(str(cmd_str), package_manager)\n                for cmd_name, cmd_str in commands.items()\n            }\n\n    # 6. Write to .atlas/modules/&lt;name&gt;.json.\n    modules_dir = os.path.join(atlas_dir, \"modules\")\n    os.makedirs(modules_dir, exist_ok=True)\n    module_path = os.path.join(modules_dir, f\"{module_name}.json\")\n    rules[\"synced_at\"] = datetime.now(tz=timezone.utc).strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n    with open(module_path, \"w\") as f:\n        json.dump(rules, f, indent=2, ensure_ascii=False)\n        f.write(\"\\n\")\n\n    # 7. Update manifest.\n    manifest.setdefault(\"installed_modules\", {})[module_name] = {\n        \"version\": bundle.get(\"version\", \"1.0.0\"),\n        \"category\": reg_entry.get(\"category\", \"\"),\n    }\n\n    return ok_result(installed=module_name, warnings=[])\n</code></pre>"},{"location":"api/modules/#atlas.core.modules.remove_module","title":"remove_module","text":"<pre><code>remove_module(\n    module_name: str,\n    registry: dict,\n    atlas_dir: str,\n    manifest: dict,\n    config: dict | None = None,\n) -&gt; dict\n</code></pre> <p>Remove a module from the project.</p> <p>Steps: 1. Validate \u2014 is installed, no other installed module requires it. 2. Scan custom tasks for references to the module (orphan detection). 3. Delete <code>.atlas/modules/&lt;name&gt;.json</code> (if present). 4. Delete <code>.atlas/retrieve/&lt;name&gt;.md</code> (if present). 5. Remove from manifest in-place.</p> <p>Returns <code>ok_result(removed=name, warnings=[...])</code> on success \u2014 warnings list contains orphaned task names (if any). Returns an <code>error_result</code> on validation failure.</p> Source code in <code>src/atlas/core/modules.py</code> <pre><code>def remove_module(\n    module_name: str,\n    registry: dict,\n    atlas_dir: str,\n    manifest: dict,\n    config: dict | None = None,\n) -&gt; dict:\n    \"\"\"Remove a module from the project.\n\n    Steps:\n    1. Validate \u2014 is installed, no other installed module requires it.\n    2. Scan custom tasks for references to the module (orphan detection).\n    3. Delete ``.atlas/modules/&lt;name&gt;.json`` (if present).\n    4. Delete ``.atlas/retrieve/&lt;name&gt;.md`` (if present).\n    5. Remove from manifest in-place.\n\n    Returns ``ok_result(removed=name, warnings=[...])`` on success \u2014\n    warnings list contains orphaned task names (if any).\n    Returns an ``error_result`` on validation failure.\n    \"\"\"\n    installed = manifest.get(\"installed_modules\", {})\n\n    if module_name not in installed:\n        return error_result(\"MODULE_NOT_INSTALLED\", module_name)\n\n    dependents = get_dependents(registry, module_name, list(installed.keys()))\n    if dependents:\n        return error_result(\n            \"MODULE_REQUIRED\",\n            f\"Required by: {', '.join(dependents)}\",\n        )\n\n    # Scan custom tasks for references to the removed module.\n    warnings = _find_orphaned_tasks(module_name, config or {})\n\n    # Delete associated files \u2014 silently skip if absent.\n    for subdir, ext in ((\"modules\", \".json\"), (\"retrieve\", \".md\")):\n        path = os.path.join(atlas_dir, subdir, f\"{module_name}{ext}\")\n        if os.path.isfile(path):\n            os.remove(path)\n\n    del manifest[\"installed_modules\"][module_name]\n\n    return ok_result(removed=module_name, warnings=warnings)\n</code></pre>"},{"location":"api/modules/#atlas.core.modules.update_modules","title":"update_modules","text":"<pre><code>update_modules(\n    registry: dict,\n    warehouse_dir: str,\n    atlas_dir: str,\n    manifest: dict,\n    package_manager: str = \"\",\n) -&gt; dict\n</code></pre> <p>Re-enrich installed modules whose warehouse version is newer.</p> <p>For each installed module: 1. Look up the warehouse version from the registry entry. 2. Skip if versions match or warehouse has no version. 3. Re-load bundle, re-scan config, re-enrich, resolve pkg variables. 4. Overwrite <code>.atlas/modules/&lt;name&gt;.json</code>. 5. Update manifest version in-place.</p> <p>Returns <code>ok_result(updated=[...], skipped=[...])</code> listing both groups.</p> Source code in <code>src/atlas/core/modules.py</code> <pre><code>def update_modules(\n    registry: dict,\n    warehouse_dir: str,\n    atlas_dir: str,\n    manifest: dict,\n    package_manager: str = \"\",\n) -&gt; dict:\n    \"\"\"Re-enrich installed modules whose warehouse version is newer.\n\n    For each installed module:\n    1. Look up the warehouse version from the registry entry.\n    2. Skip if versions match or warehouse has no version.\n    3. Re-load bundle, re-scan config, re-enrich, resolve pkg variables.\n    4. Overwrite ``.atlas/modules/&lt;name&gt;.json``.\n    5. Update manifest version in-place.\n\n    Returns ``ok_result(updated=[...], skipped=[...])`` listing both groups.\n    \"\"\"\n    installed = manifest.get(\"installed_modules\", {})\n    updated: list[str] = []\n    skipped: list[str] = []\n\n    project_dir = os.path.dirname(os.path.abspath(atlas_dir))\n    modules_dir = os.path.join(atlas_dir, \"modules\")\n    os.makedirs(modules_dir, exist_ok=True)\n\n    for module_name, meta in installed.items():\n        reg_entry = find_module(registry, module_name)\n        if not reg_entry:\n            skipped.append(module_name)\n            continue\n\n        warehouse_version = reg_entry.get(\"version\", \"\")\n        installed_version = meta.get(\"version\", \"\")\n\n        if not warehouse_version or warehouse_version == installed_version:\n            skipped.append(module_name)\n            continue\n\n        # Re-load bundle.\n        bundle = load_module_bundle(module_name, registry, warehouse_dir)\n        if not bundle:\n            bundle = {\n                \"id\": module_name,\n                \"category\": reg_entry.get(\"category\", \"\"),\n                \"version\": warehouse_version,\n            }\n\n        # Re-scan config.\n        scan_result = scan_module_config(module_name, project_dir)\n\n        # Re-enrich.\n        rules = dict(bundle)\n        if scan_result.get(\"found\"):\n            rules[\"config_file\"] = scan_result.get(\"config_file\", \"\")\n            rules[\"config_section\"] = scan_result.get(\"config_section\", \"\")\n            extracted = scan_result.get(\"extracted\", {})\n            if extracted:\n                rules.setdefault(\"rules\", {}).update(extracted)\n\n        # Resolve pkg variables.\n        if package_manager:\n            commands = rules.get(\"commands\", {})\n            if commands:\n                rules[\"commands\"] = {\n                    cmd_name: resolve_pkg_variables(str(cmd_str), package_manager)\n                    for cmd_name, cmd_str in commands.items()\n                }\n\n        # Overwrite module file.\n        module_path = os.path.join(modules_dir, f\"{module_name}.json\")\n        rules[\"synced_at\"] = datetime.now(tz=timezone.utc).strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n        with open(module_path, \"w\") as f:\n            json.dump(rules, f, indent=2, ensure_ascii=False)\n            f.write(\"\\n\")\n\n        # Update manifest version.\n        manifest[\"installed_modules\"][module_name][\"version\"] = warehouse_version\n\n        updated.append(module_name)\n\n    return ok_result(updated=updated, skipped=skipped)\n</code></pre>"},{"location":"api/parser/","title":"atlas.parser","text":""},{"location":"api/parser/#atlas.parser","title":"atlas.parser","text":"<p>Universal input parser for the atlas MCP tool.</p> <p>One tool, one string input.  The parser extracts: - verb          \u2014 action word (init, add, create, edit, remove, list, just, vcs, crud, sync) - resource_type \u2014 sub-type for create/edit/remove (note, prompt, task, scope) - contexts      \u2014 retrieve query groups: [[\"python\", \"linter\"], [\"svelte\"]] - args          \u2014 remaining positional arguments - message       \u2014 agent passthrough text after \" -- \"</p>"},{"location":"api/parser/#atlas.parser.ParsedInput","title":"ParsedInput  <code>dataclass</code>","text":"<pre><code>ParsedInput(\n    verb: str | None = None,\n    resource_type: str | None = None,\n    contexts: list[list[str]] = list(),\n    args: list[str] = list(),\n    message: str | None = None,\n)\n</code></pre> <p>Structured representation of a single atlas tool invocation.</p>"},{"location":"api/parser/#atlas.parser.parse_input","title":"parse_input","text":"<pre><code>parse_input(raw: str) -&gt; ParsedInput\n</code></pre> <p>Parse a raw atlas tool input string into a :class:<code>ParsedInput</code>.</p> <p>Syntax rules: - First word is a verb \u2192 verb mode (args follow). - No verb \u2192 context query mode (commas combine, spaces filter). - <code>\" -- \"</code> separator extracts agent passthrough into <code>message</code>. - <code>create</code>/<code>edit</code> + resource_type word \u2192 <code>resource_type</code> set, rest \u2192 <code>args</code>. - <code>remove</code> + resource_type + \u22651 more word \u2192 <code>resource_type</code> set, rest \u2192 <code>args</code>.</p> Source code in <code>src/atlas/parser.py</code> <pre><code>def parse_input(raw: str) -&gt; ParsedInput:\n    \"\"\"Parse a raw atlas tool input string into a :class:`ParsedInput`.\n\n    Syntax rules:\n    - First word is a verb \u2192 verb mode (args follow).\n    - No verb \u2192 context query mode (commas combine, spaces filter).\n    - ``\" -- \"`` separator extracts agent passthrough into ``message``.\n    - ``create``/``edit`` + resource_type word \u2192 ``resource_type`` set, rest \u2192 ``args``.\n    - ``remove`` + resource_type + \u22651 more word \u2192 ``resource_type`` set, rest \u2192 ``args``.\n    \"\"\"\n    raw = raw.strip()\n    result = ParsedInput()\n\n    # Split on \" -- \" for agent passthrough\n    if \" -- \" in raw:\n        atlas_part, result.message = raw.split(\" -- \", 1)\n    else:\n        atlas_part = raw\n\n    words = atlas_part.split()\n    if not words:\n        return result\n\n    first = words[0].lower()\n    if first in VERBS:\n        result.verb = first\n        rest = words[1:]\n\n        if result.verb in (\"create\", \"edit\") and rest and rest[0] in RESOURCE_TYPES:\n            result.resource_type = rest[0]\n            result.args = rest[1:]\n        elif result.verb == \"remove\" and len(rest) &gt;= 2 and rest[0] in RESOURCE_TYPES:\n            result.resource_type = rest[0]\n            result.args = rest[1:]\n        else:\n            result.args = rest\n    else:\n        # No verb \u2192 context query: split by comma, then by space\n        groups = [g.strip() for g in atlas_part.split(\",\")]\n        result.contexts = [g.split() for g in groups if g]\n\n    return result\n</code></pre>"},{"location":"api/registry/","title":"atlas.core.registry","text":""},{"location":"api/registry/#atlas.core.registry","title":"atlas.core.registry","text":"<p>Global module registry loading and querying.</p>"},{"location":"api/registry/#atlas.core.registry.load_registry","title":"load_registry","text":"<pre><code>load_registry(registry_path: str) -&gt; dict\n</code></pre> <p>Load registry.json from registry_path.</p> <p>Returns an empty dict if the file does not exist, cannot be read, or contains invalid JSON.</p> Source code in <code>src/atlas/core/registry.py</code> <pre><code>def load_registry(registry_path: str) -&gt; dict:\n    \"\"\"Load registry.json from *registry_path*.\n\n    Returns an empty dict if the file does not exist, cannot be read,\n    or contains invalid JSON.\n    \"\"\"\n    if not os.path.isfile(registry_path):\n        return {}\n    try:\n        with open(registry_path) as f:\n            return json.load(f)\n    except (json.JSONDecodeError, OSError):\n        return {}\n</code></pre>"},{"location":"api/registry/#atlas.core.registry.find_module","title":"find_module","text":"<pre><code>find_module(registry: dict, module_name: str) -&gt; dict\n</code></pre> <p>Return the registry entry for module_name, or {} if not found.</p> Source code in <code>src/atlas/core/registry.py</code> <pre><code>def find_module(registry: dict, module_name: str) -&gt; dict:\n    \"\"\"Return the registry entry for *module_name*, or {} if not found.\"\"\"\n    return registry.get(\"modules\", {}).get(module_name, {})\n</code></pre>"},{"location":"api/registry/#atlas.core.registry.check_conflicts","title":"check_conflicts","text":"<pre><code>check_conflicts(\n    registry: dict, module_name: str, installed: list[str]\n) -&gt; list[str]\n</code></pre> <p>Return names of installed modules that conflict with module_name.</p> <p>Checks both directions: 1. <code>module_name</code>'s own <code>conflicts_with</code> list (new module declares conflict) 2. Each installed module's <code>conflicts_with</code> list (existing module declares conflict)</p> <p>Returns deduplicated conflicting names. An empty list means no conflicts.</p> Source code in <code>src/atlas/core/registry.py</code> <pre><code>def check_conflicts(\n    registry: dict, module_name: str, installed: list[str]\n) -&gt; list[str]:\n    \"\"\"Return names of *installed* modules that conflict with *module_name*.\n\n    Checks both directions:\n    1. ``module_name``'s own ``conflicts_with`` list (new module declares conflict)\n    2. Each installed module's ``conflicts_with`` list (existing module declares conflict)\n\n    Returns deduplicated conflicting names. An empty list means no conflicts.\n    \"\"\"\n    modules = registry.get(\"modules\", {})\n\n    # Direction 1: new module's own conflicts_with\n    mod_info = find_module(registry, module_name)\n    forward = set(mod_info.get(\"conflicts_with\", [])) if mod_info else set()\n\n    # Direction 2: installed modules that list module_name in their conflicts_with\n    reverse = {\n        name\n        for name in installed\n        if module_name in modules.get(name, {}).get(\"conflicts_with\", [])\n    }\n\n    return [c for c in installed if c in (forward | reverse)]\n</code></pre>"},{"location":"api/registry/#atlas.core.registry.get_dependencies","title":"get_dependencies","text":"<pre><code>get_dependencies(\n    registry: dict, module_name: str\n) -&gt; list[str]\n</code></pre> <p>Return the <code>requires</code> list for module_name.</p> <p>Returns an empty list if the module is not found or has no dependencies.</p> Source code in <code>src/atlas/core/registry.py</code> <pre><code>def get_dependencies(registry: dict, module_name: str) -&gt; list[str]:\n    \"\"\"Return the ``requires`` list for *module_name*.\n\n    Returns an empty list if the module is not found or has no\n    dependencies.\n    \"\"\"\n    mod_info = find_module(registry, module_name)\n    if not mod_info:\n        return []\n    return list(mod_info.get(\"requires\", []))\n</code></pre>"},{"location":"api/registry/#atlas.core.registry.get_dependents","title":"get_dependents","text":"<pre><code>get_dependents(\n    registry: dict, module_name: str, installed: list[str]\n) -&gt; list[str]\n</code></pre> <p>Return names of installed modules that require module_name.</p> <p>Used on <code>remove</code> to block removal when other modules depend on the target.  Returns an empty list when it is safe to remove.</p> Source code in <code>src/atlas/core/registry.py</code> <pre><code>def get_dependents(\n    registry: dict, module_name: str, installed: list[str]\n) -&gt; list[str]:\n    \"\"\"Return names of *installed* modules that require *module_name*.\n\n    Used on ``remove`` to block removal when other modules depend on the\n    target.  Returns an empty list when it is safe to remove.\n    \"\"\"\n    modules = registry.get(\"modules\", {})\n    return [\n        name\n        for name in installed\n        if name != module_name\n        and module_name in modules.get(name, {}).get(\"requires\", [])\n    ]\n</code></pre>"},{"location":"api/registry/#atlas.core.registry.find_init_conflicts","title":"find_init_conflicts","text":"<pre><code>find_init_conflicts(\n    registry: dict, detected: list[str]\n) -&gt; list[tuple[str, str]]\n</code></pre> <p>Return conflicting pairs among detected modules.</p> <p>During <code>init</code>, the detection engine may find multiple tools in the project that cannot coexist (e.g. both ruff and flake8 detected). This function returns all such pairs so the init proposal can flag them for the agent / user to resolve.</p> <p>Each returned tuple <code>(a, b)</code> means <code>a</code> and <code>b</code> conflict, where <code>a</code> appears before <code>b</code> in detected.  Each pair is reported once.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>dict</code> <p>The loaded registry dict.</p> required <code>detected</code> <code>list[str]</code> <p>Module names found in the project by the detection engine.</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>List of <code>(module_a, module_b)</code> conflict tuples.</p> Source code in <code>src/atlas/core/registry.py</code> <pre><code>def find_init_conflicts(registry: dict, detected: list[str]) -&gt; list[tuple[str, str]]:\n    \"\"\"Return conflicting pairs among *detected* modules.\n\n    During ``init``, the detection engine may find multiple tools in the\n    project that cannot coexist (e.g. both ruff and flake8 detected).\n    This function returns all such pairs so the init proposal can flag\n    them for the agent / user to resolve.\n\n    Each returned tuple ``(a, b)`` means ``a`` and ``b`` conflict, where\n    ``a`` appears before ``b`` in *detected*.  Each pair is reported once.\n\n    Args:\n        registry: The loaded registry dict.\n        detected: Module names found in the project by the detection engine.\n\n    Returns:\n        List of ``(module_a, module_b)`` conflict tuples.\n    \"\"\"\n    modules = registry.get(\"modules\", {})\n    detected_set = set(detected)\n    seen: set[frozenset] = set()\n    conflicts: list[tuple[str, str]] = []\n\n    for name in detected:\n        mod_info = modules.get(name, {})\n        for other in mod_info.get(\"conflicts_with\", []):\n            if other in detected_set:\n                pair = frozenset({name, other})\n                if pair not in seen:\n                    seen.add(pair)\n                    conflicts.append((name, other))\n\n    return conflicts\n</code></pre>"},{"location":"api/registry/#atlas.core.registry.get_recommendations","title":"get_recommendations","text":"<pre><code>get_recommendations(\n    registry: dict, detection: object\n) -&gt; list[dict]\n</code></pre> <p>Return recommended modules based on detection results.</p> <p>detection is a <code>ProjectDetection</code> dataclass (or any object with the same attributes).  Each returned dict has the shape::</p> <pre><code>{\"name\": str, \"category\": str, \"reason\": str}\n</code></pre> <p>Results are ordered by category priority (vcs \u2192 language \u2192 pkg_manager \u2192 linter \u2192 formatter \u2192 testing \u2192 \u2026). An empty list is returned when nothing matches or on bad input.</p> Source code in <code>src/atlas/core/registry.py</code> <pre><code>def get_recommendations(registry: dict, detection: object) -&gt; list[dict]:\n    \"\"\"Return recommended modules based on *detection* results.\n\n    *detection* is a ``ProjectDetection`` dataclass (or any object with\n    the same attributes).  Each returned dict has the shape::\n\n        {\"name\": str, \"category\": str, \"reason\": str}\n\n    Results are ordered by category priority (vcs \u2192 language \u2192\n    pkg_manager \u2192 linter \u2192 formatter \u2192 testing \u2192 \u2026).\n    An empty list is returned when nothing matches or on bad input.\n    \"\"\"\n    modules = registry.get(\"modules\", {})\n    if not modules:\n        return []\n\n    # Safely pull detection attributes \u2014 tolerate plain dicts or dataclasses.\n    def _attr(name: str, default):\n        if isinstance(detection, dict):\n            return detection.get(name, default)\n        return getattr(detection, name, default)\n\n    detected_languages: list[str] = _attr(\"languages\", [])\n    detected_frameworks: list[str] = _attr(\"frameworks\", [])\n    detected_databases: list[str] = _attr(\"databases\", [])\n    detected_pkg_manager: str = _attr(\"package_manager\", \"none\")\n    detected_tools: list[str] = _attr(\"existing_tools\", [])\n    detected_stack: str = _attr(\"stack\", \"\")\n\n    recommendations: list[dict] = []\n\n    for name, entry in modules.items():\n        category = entry.get(\"category\", \"\")\n        for_languages: list[str] = entry.get(\"for_languages\", [])\n        reason: str = \"\"\n\n        # If the module targets specific languages, skip unless one matches.\n        if for_languages and not any(\n            lang in detected_languages for lang in for_languages\n        ):\n            continue\n\n        if category == \"language\":\n            detect_files: list[str] = entry.get(\"detect_files\", [])\n            # Include language module if this language was detected.\n            if name in detected_languages:\n                reason = f\"detected language: {name}\"\n            else:\n                continue\n\n        elif category == \"framework\":\n            if name in detected_frameworks:\n                reason = f\"detected framework: {name}\"\n            else:\n                continue\n\n        elif category == \"database\":\n            if name in detected_databases:\n                reason = f\"detected database: {name}\"\n            else:\n                continue\n\n        elif category == \"pkg_manager\":\n            if name == detected_pkg_manager:\n                reason = f\"detected package manager: {name}\"\n            else:\n                continue\n\n        elif category == \"stack\":\n            if name == detected_stack:\n                reason = f\"detected stack: {name}\"\n            else:\n                continue\n\n        elif category in (\"vcs\", \"linter\", \"formatter\", \"testing\",\n                          \"environment\", \"ci_cd\", \"platform\", \"tool\"):\n            # Include if the tool was detected in existing_tools, or\n            # always include vcs when any vcs tool is detected.\n            if name in detected_tools:\n                reason = f\"detected tool: {name}\"\n            elif category == \"vcs\" and any(t in detected_tools for t in (\"git\",)):\n                # Generic vcs match \u2014 only include the specific detected vcs.\n                continue\n            else:\n                continue\n\n        else:\n            # Unknown category \u2014 skip.\n            continue\n\n        recommendations.append({\"name\": name, \"category\": category, \"reason\": reason})\n\n    recommendations.sort(key=lambda r: _category_rank(r[\"category\"]))\n    return recommendations\n</code></pre>"},{"location":"api/registry/#atlas.core.registry.load_module_bundle","title":"load_module_bundle","text":"<pre><code>load_module_bundle(\n    module_name: str, registry: dict, warehouse_dir: str\n) -&gt; dict\n</code></pre> <p>Load the <code>module.json</code> for module_name from the warehouse.</p> <p>Resolves the bundle directory via the registry entry's <code>path</code> field.  Returns an empty dict if the module is not registered, the path is missing, the file does not exist, or JSON parsing fails.</p> Source code in <code>src/atlas/core/registry.py</code> <pre><code>def load_module_bundle(\n    module_name: str, registry: dict, warehouse_dir: str\n) -&gt; dict:\n    \"\"\"Load the ``module.json`` for *module_name* from the warehouse.\n\n    Resolves the bundle directory via the registry entry's ``path``\n    field.  Returns an empty dict if the module is not registered, the\n    path is missing, the file does not exist, or JSON parsing fails.\n    \"\"\"\n    reg_entry = find_module(registry, module_name)\n    if not reg_entry:\n        return {}\n\n    module_path = reg_entry.get(\"path\", \"\")\n    if not module_path:\n        return {}\n\n    module_json = os.path.join(warehouse_dir, module_path, \"module.json\")\n    if not os.path.isfile(module_json):\n        return {}\n\n    try:\n        with open(module_json) as f:\n            return json.load(f)\n    except (json.JSONDecodeError, OSError):\n        return {}\n</code></pre>"},{"location":"api/registry/#atlas.core.registry.load_module_rules_md","title":"load_module_rules_md","text":"<pre><code>load_module_rules_md(\n    module_name: str, registry: dict, warehouse_dir: str\n) -&gt; str\n</code></pre> <p>Load the <code>rules.md</code> content for module_name from the warehouse.</p> <p>Returns the markdown string, or an empty string if the module is not registered, the path is missing, the file does not exist, or the file cannot be read.</p> Source code in <code>src/atlas/core/registry.py</code> <pre><code>def load_module_rules_md(\n    module_name: str, registry: dict, warehouse_dir: str\n) -&gt; str:\n    \"\"\"Load the ``rules.md`` content for *module_name* from the warehouse.\n\n    Returns the markdown string, or an empty string if the module is not\n    registered, the path is missing, the file does not exist, or the\n    file cannot be read.\n    \"\"\"\n    reg_entry = find_module(registry, module_name)\n    if not reg_entry:\n        return \"\"\n\n    module_path = reg_entry.get(\"path\", \"\")\n    if not module_path:\n        return \"\"\n\n    rules_file = os.path.join(warehouse_dir, module_path, \"rules.md\")\n    if not os.path.isfile(rules_file):\n        return \"\"\n\n    try:\n        with open(rules_file) as f:\n            return f.read()\n    except OSError:\n        return \"\"\n</code></pre>"},{"location":"api/retrieve/","title":"atlas.core.retrieve","text":""},{"location":"api/retrieve/#atlas.core.retrieve","title":"atlas.core.retrieve","text":"<p>Build pre-computed retrieve files from module rules and warehouse content.</p>"},{"location":"api/retrieve/#atlas.core.retrieve.build_retrieve_file","title":"build_retrieve_file","text":"<pre><code>build_retrieve_file(\n    module_name: str,\n    atlas_dir: str,\n    registry: dict,\n    warehouse_dir: str,\n    installed_modules: dict,\n    config: dict | None = None,\n) -&gt; str\n</code></pre> <p>Build a single retrieve .md file for a module.</p> <p>Combines: 1. rules.md from warehouse (base content) 2. Extracted config values from .atlas/modules/.json 3. Linked module summaries (if configured in retrieve_links) <p>Returns the built Markdown content.</p> Source code in <code>src/atlas/core/retrieve.py</code> <pre><code>def build_retrieve_file(\n    module_name: str,\n    atlas_dir: str,\n    registry: dict,\n    warehouse_dir: str,\n    installed_modules: dict,\n    config: dict | None = None,\n) -&gt; str:\n    \"\"\"Build a single retrieve .md file for a module.\n\n    Combines:\n    1. rules.md from warehouse (base content)\n    2. Extracted config values from .atlas/modules/&lt;name&gt;.json\n    3. Linked module summaries (if configured in retrieve_links)\n\n    Returns the built Markdown content.\n    \"\"\"\n    config = config or {}\n\n    # Read base rules from warehouse\n    content = load_module_rules_md(module_name, registry, warehouse_dir)\n\n    # Read extracted values from installed module rules\n    module_rules = _load_module_rules(module_name, atlas_dir)\n\n    # Inject values following the truth hierarchy:\n    #   Priority 1 \u2014 snapshot (.atlas/modules/&lt;name&gt;.json) overrides warehouse defaults\n    #   Priority 4 \u2014 warehouse rules.md provides the base template\n    # All non-meta keys are injected: extracted config values AND commands.\n    if module_rules:\n        _META_KEYS = {\n            \"id\", \"name\", \"version\", \"category\", \"description\",\n            \"config_file\", \"config_section\", \"detect_files\",\n            \"detect_in_config\", \"for_languages\", \"requires\",\n            \"combines_with\", \"conflicts_with\", \"config_locations\",\n            \"config_keys\", \"system_tool\", \"health_check\", \"unlocks_verb\",\n            \"synced_at\",\n        }\n        for key, value in module_rules.items():\n            if key in _META_KEYS:\n                continue\n            if isinstance(value, dict):\n                content = _inject_values(content, value, prefix=key)\n            else:\n                content = content.replace(\"{{\" + key + \"}}\", str(value))\n\n        # Add config source info\n        config_file = module_rules.get(\"config_file\", \"\")\n        if config_file:\n            content += f\"\\n\\n&gt; Config source: `{config_file}`\\n\"\n\n        # Add freshness timestamp\n        synced_at = module_rules.get(\"synced_at\", \"\")\n        if synced_at:\n            freshness = _format_freshness(synced_at)\n            content += f\"\\n\\n&gt; {freshness}\\n\"\n\n    # Append linked module summaries\n    retrieve_links = config.get(\"retrieve_links\", {})\n    linked = retrieve_links.get(module_name, [])\n    for linked_name in linked:\n        if linked_name in installed_modules and linked_name != module_name:\n            linked_content = load_module_rules_md(linked_name, registry, warehouse_dir)\n            if linked_content:\n                summary = _condense(linked_content, max_sections=2)\n                content += f\"\\n\\n---\\n\\n## Linked: {linked_name}\\n\\n{summary}\"\n\n    return content\n</code></pre>"},{"location":"api/retrieve/#atlas.core.retrieve.build_status_file","title":"build_status_file","text":"<pre><code>build_status_file(\n    manifest: dict, installed_modules: dict\n) -&gt; str\n</code></pre> <p>Build the _status.md overview file.</p> <p>This is the first thing agents read at session start. It contains: - Project type, languages, stack - Installed modules grouped by category - Available commands - Retrieval hints</p> Source code in <code>src/atlas/core/retrieve.py</code> <pre><code>def build_status_file(manifest: dict, installed_modules: dict) -&gt; str:\n    \"\"\"Build the _status.md overview file.\n\n    This is the first thing agents read at session start. It contains:\n    - Project type, languages, stack\n    - Installed modules grouped by category\n    - Available commands\n    - Retrieval hints\n    \"\"\"\n    detected = manifest.get(\"detected\", {})\n    languages = detected.get(\"languages\", [])\n    stack = detected.get(\"stack\", \"\")\n    pkg_mgr = detected.get(\"package_manager\", \"\")\n\n    lines = [\"# Atlas Project Status\", \"\"]\n\n    # Project overview\n    if languages:\n        lines.append(f\"**Languages:** {', '.join(languages)}\")\n    if stack:\n        lines.append(f\"**Stack:** {stack}\")\n    if pkg_mgr and pkg_mgr != \"none\":\n        lines.append(f\"**Package Manager:** {pkg_mgr}\")\n    lines.append(\"\")\n\n    # Installed modules by category\n    by_category: dict[str, list[str]] = {}\n    for mod_name, mod_info in installed_modules.items():\n        cat = mod_info.get(\"category\", \"other\")\n        by_category.setdefault(cat, []).append(mod_name)\n\n    if by_category:\n        lines.append(\"## Installed Modules\")\n        for cat in sorted(by_category):\n            mods = \", \".join(sorted(by_category[cat]))\n            lines.append(f\"- **{cat}:** {mods}\")\n        lines.append(\"\")\n\n    # Available retrieve targets\n    retrievable = sorted(list(installed_modules.keys()) + [\"structure\", \"project\"])\n    lines.append(f\"## Retrievable: {', '.join(retrievable)}\")\n    lines.append(\"\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/retrieve/#atlas.core.retrieve.build_all_retrieve_files","title":"build_all_retrieve_files","text":"<pre><code>build_all_retrieve_files(\n    atlas_dir: str,\n    registry: dict,\n    warehouse_dir: str,\n    manifest: dict,\n    config: dict | None = None,\n) -&gt; list[str]\n</code></pre> <p>Build all retrieve files for all installed modules + auto-modules.</p> <p>Returns list of module names that were built.</p> Source code in <code>src/atlas/core/retrieve.py</code> <pre><code>def build_all_retrieve_files(\n    atlas_dir: str,\n    registry: dict,\n    warehouse_dir: str,\n    manifest: dict,\n    config: dict | None = None,\n) -&gt; list[str]:\n    \"\"\"Build all retrieve files for all installed modules + auto-modules.\n\n    Returns list of module names that were built.\n    \"\"\"\n    config = config or {}\n    installed = manifest.get(\"installed_modules\", {})\n    retrieve_dir = os.path.join(atlas_dir, \"retrieve\")\n    os.makedirs(retrieve_dir, exist_ok=True)\n    built = []\n\n    for mod_name in installed:\n        content = build_retrieve_file(\n            mod_name, atlas_dir, registry, warehouse_dir, installed, config\n        )\n        if content:\n            path = os.path.join(retrieve_dir, f\"{mod_name}.md\")\n            with open(path, \"w\") as f:\n                f.write(content)\n            built.append(mod_name)\n\n    # Build status file\n    status_content = build_status_file(manifest, installed)\n    with open(os.path.join(retrieve_dir, \"_status.md\"), \"w\") as f:\n        f.write(status_content)\n    built.append(\"_status\")\n\n    return built\n</code></pre>"},{"location":"api/retrieve/#atlas.core.retrieve.filter_sections","title":"filter_sections","text":"<pre><code>filter_sections(\n    content: str, filter_words: list[str]\n) -&gt; str\n</code></pre> <p>Return only the sections of content whose headers match any filter word.</p> <p>A section begins at any line starting with <code>#</code> and ends just before the next same-or-higher-level header (or at end-of-string).  Filter words are matched case-insensitively against the header text.</p> <p>If filter_words is empty or nothing matches, the original content is returned unchanged.</p> Source code in <code>src/atlas/core/retrieve.py</code> <pre><code>def filter_sections(content: str, filter_words: list[str]) -&gt; str:\n    \"\"\"Return only the sections of *content* whose headers match any filter word.\n\n    A section begins at any line starting with ``#`` and ends just before the\n    next same-or-higher-level header (or at end-of-string).  Filter words are\n    matched case-insensitively against the header text.\n\n    If *filter_words* is empty or nothing matches, the original *content* is\n    returned unchanged.\n    \"\"\"\n    if not filter_words:\n        return content\n\n    lines = content.split(\"\\n\")\n    # Collect sections: each entry is (header_line_index, header_level, [lines])\n    sections: list[tuple[int, int, list[str]]] = []\n    preamble: list[str] = []\n    current_section: list[str] | None = None\n    current_level = 0\n\n    for line in lines:\n        stripped = line.lstrip(\"#\")\n        level = len(line) - len(stripped)\n        if level &gt; 0 and line.startswith(\"#\"):\n            current_section = [line]\n            current_level = level\n            sections.append((level, current_section))\n        elif current_section is not None:\n            current_section.append(line)\n        else:\n            preamble.append(line)\n\n    lower_filters = [w.lower() for w in filter_words]\n\n    matching: list[str] = []\n    for level, section_lines in sections:\n        header = section_lines[0].lstrip(\"#\").strip().lower()\n        if any(f in header for f in lower_filters):\n            matching.extend(section_lines)\n\n    if not matching:\n        return content\n\n    return \"\\n\".join(matching).strip()\n</code></pre>"},{"location":"api/runner/","title":"atlas.core.runner","text":""},{"location":"api/runner/#atlas.core.runner","title":"atlas.core.runner","text":"<p>Task execution via subprocess with local-first tool resolution.</p>"},{"location":"api/runner/#atlas.core.runner.resolve_tool","title":"resolve_tool","text":"<pre><code>resolve_tool(\n    tool_name: str, project_dir: str\n) -&gt; str | None\n</code></pre> <p>Return the path to tool_name, preferring project-local installations.</p> <p>Resolution cascade: 1. <code>&lt;project_dir&gt;/.venv/bin/&lt;tool&gt;</code> (Python virtual environment) 2. <code>&lt;project_dir&gt;/node_modules/.bin/&lt;tool&gt;</code> (Node.js local packages) 3. <code>shutil.which(&lt;tool&gt;)</code> (system PATH) 4. None \u2014 tool not found</p> <p>Atlas NEVER installs packages; it only informs when a tool is missing.</p> Source code in <code>src/atlas/core/runner.py</code> <pre><code>def resolve_tool(tool_name: str, project_dir: str) -&gt; str | None:\n    \"\"\"Return the path to *tool_name*, preferring project-local installations.\n\n    Resolution cascade:\n    1. ``&lt;project_dir&gt;/.venv/bin/&lt;tool&gt;`` (Python virtual environment)\n    2. ``&lt;project_dir&gt;/node_modules/.bin/&lt;tool&gt;`` (Node.js local packages)\n    3. ``shutil.which(&lt;tool&gt;)`` (system PATH)\n    4. None \u2014 tool not found\n\n    Atlas NEVER installs packages; it only informs when a tool is missing.\n    \"\"\"\n    candidates = [\n        os.path.join(project_dir, \".venv\", \"bin\", tool_name),\n        os.path.join(project_dir, \"node_modules\", \".bin\", tool_name),\n    ]\n    for path in candidates:\n        if os.path.isfile(path) and os.access(path, os.X_OK):\n            return path\n\n    return shutil.which(tool_name)\n</code></pre>"},{"location":"api/runner/#atlas.core.runner.run_task","title":"run_task","text":"<pre><code>run_task(\n    task_name: str,\n    command: str,\n    project_dir: str,\n    timeout: int = 60,\n) -&gt; dict\n</code></pre> <p>Execute command as a shell command in project_dir.</p> <p>Returns <code>ok_result(task=task_name, output=..., returncode=...)</code> on completion (even when the command exits non-zero, so the caller can decide how to handle failures).</p> <p>Returns <code>error_result</code> when: - command is empty - The executable is not found (exit code 127) - The command times out (exit code 124)</p> Source code in <code>src/atlas/core/runner.py</code> <pre><code>def run_task(\n    task_name: str,\n    command: str,\n    project_dir: str,\n    timeout: int = 60,\n) -&gt; dict:\n    \"\"\"Execute *command* as a shell command in *project_dir*.\n\n    Returns ``ok_result(task=task_name, output=..., returncode=...)`` on\n    completion (even when the command exits non-zero, so the caller can\n    decide how to handle failures).\n\n    Returns ``error_result`` when:\n    - *command* is empty\n    - The executable is not found (exit code 127)\n    - The command times out (exit code 124)\n    \"\"\"\n    if not command or not command.strip():\n        return error_result(\"INVALID_ARGUMENT\", f\"No command for task '{task_name}'\")\n\n    try:\n        args = shlex.split(command)\n    except ValueError as exc:\n        return error_result(\"INVALID_ARGUMENT\", f\"Cannot parse command: {exc}\")\n\n    try:\n        proc = subprocess.run(\n            args,\n            cwd=project_dir,\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n            check=False,\n        )\n        output = (proc.stdout + proc.stderr).strip()\n        return ok_result(task=task_name, output=output, returncode=proc.returncode)\n    except FileNotFoundError:\n        return error_result(\n            \"INVALID_ARGUMENT\",\n            f\"Executable not found for task '{task_name}': {args[0]}\",\n        )\n    except subprocess.TimeoutExpired:\n        return error_result(\n            \"INVALID_ARGUMENT\",\n            f\"Task '{task_name}' timed out after {timeout}s\",\n        )\n</code></pre>"},{"location":"api/runtime/","title":"atlas.runtime","text":""},{"location":"api/runtime/#atlas.runtime","title":"atlas.runtime","text":"<p>Atlas runtime \u2014 the stateful core used by both the MCP server and CLI.</p> <p>One instance per server session (or per CLI invocation).  Lazy-loaded properties mean nothing is read from disk until actually needed.</p>"},{"location":"api/runtime/#atlas.runtime.Atlas","title":"Atlas","text":"<pre><code>Atlas(project_dir: str | None = None)\n</code></pre> <p>Runtime state for Atlas.</p> <p>Created once per server session (MCP) or once per CLI invocation. Holds lazy-loaded references to manifest, registry, config, and router. All heavy I/O is deferred until the first access.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def __init__(self, project_dir: str | None = None) -&gt; None:\n    self.project_dir: str = os.path.abspath(project_dir or os.getcwd())\n    self.atlas_dir: str = os.path.join(self.project_dir, \".atlas\")\n    self.warehouse_dir: str = self._find_warehouse()\n\n    # Lazy backing fields\n    self._manifest: dict | None = None\n    self._config: AtlasConfig | None = None\n    self._registry: dict | None = None\n    self._router: CategoryRouter | None = None\n    self._notes: dict | None = None\n    self._context: dict | None = None\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.is_initialized","title":"is_initialized  <code>property</code>","text":"<pre><code>is_initialized: bool\n</code></pre> <p>True when the .atlas/ directory exists.</p>"},{"location":"api/runtime/#atlas.runtime.Atlas.invalidate","title":"invalidate","text":"<pre><code>invalidate() -&gt; None\n</code></pre> <p>Clear all cached state.</p> <p>Call after any operation that modifies .atlas/ so the next access reloads fresh data from disk.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def invalidate(self) -&gt; None:\n    \"\"\"Clear all cached state.\n\n    Call after any operation that modifies .atlas/ so the next access\n    reloads fresh data from disk.\n    \"\"\"\n    self._manifest = None\n    self._config = None\n    self._registry = None\n    self._router = None\n    self._notes = None\n    self._context = None\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.save_manifest","title":"save_manifest","text":"<pre><code>save_manifest() -&gt; None\n</code></pre> <p>Persist the in-memory manifest to .atlas/manifest.json.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def save_manifest(self) -&gt; None:\n    \"\"\"Persist the in-memory manifest to .atlas/manifest.json.\"\"\"\n    if self._manifest is not None:\n        self._write_json(\n            os.path.join(self.atlas_dir, \"manifest.json\"), self._manifest\n        )\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.save_notes","title":"save_notes","text":"<pre><code>save_notes() -&gt; None\n</code></pre> <p>Persist the in-memory notes to .atlas/notes.json.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def save_notes(self) -&gt; None:\n    \"\"\"Persist the in-memory notes to .atlas/notes.json.\"\"\"\n    if self._notes is not None:\n        self._write_json(\n            os.path.join(self.atlas_dir, \"notes.json\"), self._notes\n        )\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.save_config","title":"save_config","text":"<pre><code>save_config(data: dict) -&gt; None\n</code></pre> <p>Persist data to .atlas/config.json.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def save_config(self, data: dict) -&gt; None:\n    \"\"\"Persist *data* to .atlas/config.json.\"\"\"\n    self._write_json(os.path.join(self.atlas_dir, \"config.json\"), data)\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.query","title":"query","text":"<pre><code>query(\n    contexts: list[list[str]], message: str | None = None\n) -&gt; str\n</code></pre> <p>Retrieve pre-built markdown for one or more context groups.</p> <p>Each group is <code>[module_name, *filter_words]</code>.  Results are concatenated with a blank line separator.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def query(\n    self,\n    contexts: list[list[str]],\n    message: str | None = None,\n) -&gt; str:\n    \"\"\"Retrieve pre-built markdown for one or more context groups.\n\n    Each group is ``[module_name, *filter_words]``.  Results are\n    concatenated with a blank line separator.\n    \"\"\"\n    parts: list[str] = []\n    retrieve_dir = os.path.join(self.atlas_dir, \"retrieve\")\n    installed = self.manifest.get(\"installed_modules\", {})\n\n    for group in contexts:\n        if not group:\n            continue\n        module_name = group[0]\n        filters = group[1:]\n\n        # Read the pre-built file\n        md_path = os.path.join(retrieve_dir, f\"{module_name}.md\")\n        if os.path.isfile(md_path):\n            try:\n                with open(md_path) as f:\n                    content = f.read()\n            except OSError:\n                content = \"\"\n        else:\n            # Fall back to building on-the-fly if not pre-built\n            content = build_retrieve_file(\n                module_name,\n                self.atlas_dir,\n                self.registry,\n                self.warehouse_dir,\n                installed,\n            )\n\n        if filters:\n            content = filter_sections(content, filters)\n\n        # Append module notes\n        module_notes = self.notes.get(module_name, [])\n        if module_notes:\n            note_lines = \"\\n\".join(\n                f\"  \u2022 {n['text']}\" for n in module_notes\n            )\n            content += f\"\\n\\n\u26a0\ufe0f Project Notes:\\n{note_lines}\"\n\n        if content:\n            parts.append(content)\n\n    result = \"\\n\\n\".join(parts)\n    if message:\n        result = f\"{result}\\n\\n---\\n{message}\" if result else message\n    return result\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.add_modules","title":"add_modules","text":"<pre><code>add_modules(names: list[str]) -&gt; dict\n</code></pre> <p>Install one or more modules from the warehouse.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def add_modules(self, names: list[str]) -&gt; dict:\n    \"\"\"Install one or more modules from the warehouse.\"\"\"\n    if not self.is_initialized:\n        return error_result(\"NOT_INITIALIZED\", \"run atlas init first\")\n\n    installed: list[str] = []\n    failed: list[dict] = []\n    pkg_mgr = self.manifest.get(\"detected\", {}).get(\"package_manager\", \"\")\n\n    for name in names:\n        result = install_module(\n            name,\n            self.registry,\n            self.warehouse_dir,\n            self.atlas_dir,\n            self.manifest,\n            package_manager=pkg_mgr,\n        )\n        if result[\"ok\"]:\n            installed.append(name)\n        else:\n            failed.append({\"name\": name, \"error\": result.get(\"error\", \"\")})\n\n    if installed:\n        self.save_manifest()\n        retrieve_dir = os.path.join(self.atlas_dir, \"retrieve\")\n        os.makedirs(retrieve_dir, exist_ok=True)\n        for name in installed:\n            content = build_retrieve_file(\n                name,\n                self.atlas_dir,\n                self.registry,\n                self.warehouse_dir,\n                self.manifest.get(\"installed_modules\", {}),\n            )\n            if content:\n                with open(os.path.join(retrieve_dir, f\"{name}.md\"), \"w\") as f:\n                    f.write(content)\n        self.invalidate()\n\n    return ok_result(installed=installed, failed=failed)\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.remove_module","title":"remove_module","text":"<pre><code>remove_module(name: str) -&gt; dict\n</code></pre> <p>Uninstall a module from the project.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def remove_module(self, name: str) -&gt; dict:\n    \"\"\"Uninstall a module from the project.\"\"\"\n    if not self.is_initialized:\n        return error_result(\"NOT_INITIALIZED\", \"run atlas init first\")\n\n    result = remove_module(name, self.registry, self.atlas_dir, self.manifest)\n    if result[\"ok\"]:\n        self.save_manifest()\n        self.invalidate()\n    return result\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.just","title":"just","text":"<pre><code>just(\n    task_name: str, extra_args: list[str] | None = None\n) -&gt; dict\n</code></pre> <p>Execute a named task from installed module commands.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def just(self, task_name: str, extra_args: list[str] | None = None) -&gt; dict:\n    \"\"\"Execute a named task from installed module commands.\"\"\"\n    if not self.is_initialized:\n        return error_result(\"NOT_INITIALIZED\", \"run atlas init first\")\n\n    if not task_name:\n        return error_result(\"INVALID_ARGUMENT\", \"task name required\")\n\n    installed_mods = self.manifest.get(\"installed_modules\", {})\n    command: str | None = None\n\n    for mod_name in installed_mods:\n        mod_json = self._load_json(\n            os.path.join(self.atlas_dir, \"modules\", f\"{mod_name}.json\"), {}\n        )\n        cmds = mod_json.get(\"commands\", {})\n        if task_name in cmds:\n            command = cmds[task_name]\n            break\n\n    if command is None:\n        return error_result(\n            \"INVALID_ARGUMENT\",\n            f\"Task '{task_name}' not found in any installed module\",\n        )\n\n    return run_task(task_name, command, self.project_dir)\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.add_note","title":"add_note","text":"<pre><code>add_note(module_name: str, text: str) -&gt; dict\n</code></pre> <p>Append a note to module_name.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def add_note(self, module_name: str, text: str) -&gt; dict:\n    \"\"\"Append a note to *module_name*.\"\"\"\n    if not self.is_initialized:\n        return error_result(\"NOT_INITIALIZED\", \"run atlas init first\")\n\n    notes_list = self.notes.setdefault(module_name, [])\n    notes_list.append({\"text\": text})\n    self.save_notes()\n    return ok_result(module=module_name, note=text, index=len(notes_list) - 1)\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.remove_note","title":"remove_note","text":"<pre><code>remove_note(module_name: str, index: int | str) -&gt; dict\n</code></pre> <p>Remove a note by index (or all notes) from module_name.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def remove_note(self, module_name: str, index: int | str) -&gt; dict:\n    \"\"\"Remove a note by index (or all notes) from *module_name*.\"\"\"\n    if not self.is_initialized:\n        return error_result(\"NOT_INITIALIZED\", \"run atlas init first\")\n\n    notes_list = self.notes.get(module_name, [])\n    if not notes_list:\n        return error_result(\"INVALID_ARGUMENT\", f\"No notes for module '{module_name}'\")\n\n    if index == \"all\":\n        self.notes[module_name] = []\n    else:\n        try:\n            idx = int(index)\n            notes_list.pop(idx)\n        except (ValueError, IndexError):\n            return error_result(\n                \"INVALID_ARGUMENT\",\n                f\"Invalid note index '{index}' for module '{module_name}'\",\n            )\n\n    self.save_notes()\n    return ok_result(module=module_name, removed=index)\n</code></pre>"},{"location":"api/runtime/#atlas.runtime.Atlas.build_session_brief","title":"build_session_brief","text":"<pre><code>build_session_brief() -&gt; str\n</code></pre> <p>Build the auto-brief text for MCP prompt injection.</p> Source code in <code>src/atlas/runtime.py</code> <pre><code>def build_session_brief(self) -&gt; str:\n    \"\"\"Build the auto-brief text for MCP prompt injection.\"\"\"\n    parts: list[str] = []\n\n    detected = self.manifest.get(\"detected\", {})\n    parts.append(f\"# Atlas \u2014 {detected.get('project_name', 'project')}\")\n    parts.append(f\"Installed: {', '.join(self.installed_modules)}\")\n\n    if self.context.get(\"active\"):\n        task = self.context[\"active\"]\n        parts.append(\n            f\"\\n## Active Task\\n\u2192 {task['type']} #{task['id']}: {task['title']}\"\n        )\n\n    all_notes: list[str] = []\n    for mod, note_list in self.notes.items():\n        for note in note_list:\n            all_notes.append(f\"  \u26a0\ufe0f {mod}: {note['text']}\")\n    if all_notes:\n        parts.append(\"\\n## Notes\\n\" + \"\\n\".join(all_notes))\n\n    parts.append(\"\\n## Atlas Tool\")\n    parts.append(\"  One tool: atlas. Spaces filter, commas combine, -- separates.\")\n    parts.append(f\"  Retrieve: {', '.join(self.installed_modules[:5])}\")\n    parts.append(\"  Help: atlas list\")\n\n    return \"\\n\".join(parts)\n</code></pre>"},{"location":"api/scanner/","title":"atlas.core.scanner","text":""},{"location":"api/scanner/#atlas.core.scanner","title":"atlas.core.scanner","text":"<p>Config scanner: reads tool configuration from project files.</p>"},{"location":"api/scanner/#atlas.core.scanner.get_config_locations","title":"get_config_locations","text":"<pre><code>get_config_locations(module_name: str) -&gt; list[dict]\n</code></pre> <p>Return the ordered config file locations for a module.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The module identifier, e.g. <code>\"ruff\"</code>.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of location dicts (file, format, section, priority),</p> <code>list[dict]</code> <p>sorted by priority ascending. Empty list if module is unknown.</p> Source code in <code>src/atlas/core/scanner.py</code> <pre><code>def get_config_locations(module_name: str) -&gt; list[dict]:\n    \"\"\"Return the ordered config file locations for a module.\n\n    Args:\n        module_name: The module identifier, e.g. ``\"ruff\"``.\n\n    Returns:\n        A list of location dicts (file, format, section, priority),\n        sorted by priority ascending. Empty list if module is unknown.\n    \"\"\"\n    locations = MODULE_CONFIG_MAP.get(module_name, [])\n    return sorted(locations, key=lambda x: x.get(\"priority\", 99))\n</code></pre>"},{"location":"api/scanner/#atlas.core.scanner.scan_module_config","title":"scan_module_config","text":"<pre><code>scan_module_config(\n    module_name: str,\n    project_dir: str,\n    config_locations: list[dict] | None = None,\n) -&gt; dict\n</code></pre> <p>Scan a project directory for a module's configuration file.</p> <p>Tries each config location in priority order. Returns on first match.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The module identifier, e.g. <code>\"ruff\"</code>.</p> required <code>project_dir</code> <code>str</code> <p>Absolute or relative path to the project root.</p> required <code>config_locations</code> <code>list[dict] | None</code> <p>Override config locations (e.g. from module.json).               Falls back to MODULE_CONFIG_MAP if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A result dict::</p> <p>{     \"found\": True,     \"config_file\": \"pyproject.toml\",     \"extracted\": {\"style\": {\"line_length\": 120}}, }</p> <code>dict</code> <p>or <code>{\"found\": False}</code> if no config file was found or the module</p> <code>dict</code> <p>is unknown.</p> Source code in <code>src/atlas/core/scanner.py</code> <pre><code>def scan_module_config(  # noqa: PLR0912\n    module_name: str,\n    project_dir: str,\n    config_locations: list[dict] | None = None,\n) -&gt; dict:\n    \"\"\"Scan a project directory for a module's configuration file.\n\n    Tries each config location in priority order. Returns on first match.\n\n    Args:\n        module_name: The module identifier, e.g. ``\"ruff\"``.\n        project_dir: Absolute or relative path to the project root.\n        config_locations: Override config locations (e.g. from module.json).\n                          Falls back to MODULE_CONFIG_MAP if None.\n\n    Returns:\n        A result dict::\n\n            {\n                \"found\": True,\n                \"config_file\": \"pyproject.toml\",\n                \"extracted\": {\"style\": {\"line_length\": 120}},\n            }\n\n        or ``{\"found\": False}`` if no config file was found or the module\n        is unknown.\n    \"\"\"\n    locations = (\n        config_locations\n        if config_locations is not None\n        else get_config_locations(module_name)\n    )\n    if not locations:\n        return {\"found\": False}\n\n    key_mapping = MODULE_CONFIG_KEYS.get(module_name, {})\n\n    for loc in locations:\n        file_pattern = loc.get(\"file\", \"\")\n        fmt = loc.get(\"format\", \"exists\")\n        section = loc.get(\"section\")\n\n        # Resolve glob patterns\n        if \"*\" in file_pattern:\n            try:\n                entries = os.listdir(project_dir)\n            except OSError:\n                continue\n            matches = [e for e in entries if fnmatch.fnmatch(e, file_pattern)]\n            if not matches:\n                continue\n            file_path = os.path.join(project_dir, matches[0])\n        else:\n            file_path = os.path.join(project_dir, file_pattern)\n\n        # Check existence based on format\n        if fmt == \"dir\":\n            if not os.path.isdir(file_path):\n                continue\n            return {\"found\": True, \"config_file\": file_pattern, \"extracted\": {}}\n\n        if fmt in (\"exists\", \"glob_exists\"):\n            if not os.path.isfile(file_path):\n                continue\n            return {\"found\": True, \"config_file\": file_pattern, \"extracted\": {}}\n\n        if not os.path.isfile(file_path):\n            continue\n\n        # Parse the file and extract values\n        raw_values: dict = {}\n\n        if fmt == \"toml\":\n            content = _read_file_safe(file_path)\n            if section:\n                section_text = _read_toml_section(content, section)\n                raw_values = _parse_toml_values(section_text)\n            else:\n                raw_values = _parse_toml_values(content)\n\n        elif fmt == \"json\":\n            data = _read_json_safe(file_path)\n            if section:\n                nested = _navigate_json_path(data, section)\n                raw_values = nested if nested is not None else {}\n            else:\n                raw_values = {\n                    k: v for k, v in data.items() if isinstance(v, (str, int, bool))\n                }\n\n        elif fmt == \"ini\":\n            raw_values = _read_ini_section(file_path, section or \"\")\n\n        elif fmt == \"yaml\":\n            raw_values = _read_yaml_simple(file_path)\n\n        elif fmt == \"gomod\":\n            raw_values = _read_gomod(file_path)\n\n        extracted = _map_extracted_values(raw_values, key_mapping) if raw_values else {}\n        return {\"found\": True, \"config_file\": file_pattern, \"extracted\": extracted}\n\n    return {\"found\": False}\n</code></pre>"},{"location":"api/scanner/#atlas.core.scanner.scan_all_modules","title":"scan_all_modules","text":"<pre><code>scan_all_modules(\n    module_names: list[str], project_dir: str\n) -&gt; dict[str, dict]\n</code></pre> <p>Scan multiple modules and return results keyed by module name.</p> <p>Parameters:</p> Name Type Description Default <code>module_names</code> <code>list[str]</code> <p>List of module identifiers to scan.</p> required <code>project_dir</code> <code>str</code> <p>Absolute or relative path to the project root.</p> required <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Dict of {module_name: scan_result} where each scan_result is the</p> <code>dict[str, dict]</code> <p>output of :func:<code>scan_module_config</code>.</p> Source code in <code>src/atlas/core/scanner.py</code> <pre><code>def scan_all_modules(module_names: list[str], project_dir: str) -&gt; dict[str, dict]:\n    \"\"\"Scan multiple modules and return results keyed by module name.\n\n    Args:\n        module_names: List of module identifiers to scan.\n        project_dir: Absolute or relative path to the project root.\n\n    Returns:\n        Dict of {module_name: scan_result} where each scan_result is the\n        output of :func:`scan_module_config`.\n    \"\"\"\n    return {name: scan_module_config(name, project_dir) for name in module_names}\n</code></pre>"},{"location":"api/scanner/#atlas.core.scanner.enrich_module_rules","title":"enrich_module_rules","text":"<pre><code>enrich_module_rules(\n    module_name: str, base_rules: dict, project_dir: str\n) -&gt; dict\n</code></pre> <p>Merge project-specific config values into a base rules dict.</p> <p>Scans the project for the module's config and deep-merges the extracted values into a copy of <code>base_rules</code>.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The module identifier, e.g. <code>\"ruff\"</code>.</p> required <code>base_rules</code> <code>dict</code> <p>The base rules dict (e.g. loaded from rules.md frontmatter).</p> required <code>project_dir</code> <code>str</code> <p>Absolute or relative path to the project root.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A new dict that is <code>base_rules</code> updated with any extracted values.</p> <code>dict</code> <p>The original <code>base_rules</code> is not modified.</p> Source code in <code>src/atlas/core/scanner.py</code> <pre><code>def enrich_module_rules(module_name: str, base_rules: dict, project_dir: str) -&gt; dict:\n    \"\"\"Merge project-specific config values into a base rules dict.\n\n    Scans the project for the module's config and deep-merges the extracted\n    values into a copy of ``base_rules``.\n\n    Args:\n        module_name: The module identifier, e.g. ``\"ruff\"``.\n        base_rules: The base rules dict (e.g. loaded from rules.md frontmatter).\n        project_dir: Absolute or relative path to the project root.\n\n    Returns:\n        A new dict that is ``base_rules`` updated with any extracted values.\n        The original ``base_rules`` is not modified.\n    \"\"\"\n    result = dict(base_rules)\n    scan = scan_module_config(module_name, project_dir)\n    if scan.get(\"found\") and scan.get(\"extracted\"):\n        for top_key, sub in scan[\"extracted\"].items():\n            if isinstance(sub, dict) and isinstance(result.get(top_key), dict):\n                result[top_key] = {**result[top_key], **sub}\n            else:\n                result[top_key] = sub\n    return result\n</code></pre>"},{"location":"api/server/","title":"atlas.server","text":""},{"location":"api/server/#atlas.server","title":"atlas.server","text":"<p>Atlas MCP server \u2014 single 'atlas' tool with dynamic description.</p> <p>One tool, one string input.  The tool description changes on every list_tools call to reflect the current project state (installed modules, available verbs).  All routing goes through the Atlas runtime class.</p>"},{"location":"api/server/#atlas.server.build_description","title":"build_description","text":"<pre><code>build_description(atlas: Atlas) -&gt; str\n</code></pre> <p>Return the dynamic tool description based on project state.</p> Source code in <code>src/atlas/server.py</code> <pre><code>def build_description(atlas: Atlas) -&gt; str:\n    \"\"\"Return the dynamic tool description based on project state.\"\"\"\n    if not atlas.is_initialized:\n        return \"Atlas project assistant. Run: atlas init \u2014 or: atlas list\"\n\n    modules = \", \".join(atlas.installed_modules)\n    verbs = [\"add\", \"create\", \"edit\", \"remove\", \"list\", \"sync\"]\n\n    if (\n        atlas.router.find_all_with_command(\"check\")\n        or atlas.router.find_all_with_command(\"test\")\n    ):\n        verbs.append(\"just\")\n    if atlas.router.has_category_installed(\"vcs\"):\n        verbs.append(\"vcs\")\n    if atlas.router.has_category_installed(\"platform\"):\n        verbs.append(\"crud\")\n\n    return (\n        f\"Atlas project assistant.\\n\"\n        f\"Modules: {modules}\\n\"\n        f\"Verbs: {', '.join(verbs)}\\n\"\n        f\"Retrieve: atlas &lt;module&gt; [filter] \u2014 \"\n        f\"Syntax: spaces filter, commas combine, -- separates\\n\"\n        f\"Help: atlas list\"\n    )\n</code></pre>"},{"location":"api/server/#atlas.server.build_input_help","title":"build_input_help","text":"<pre><code>build_input_help(atlas: Atlas) -&gt; str\n</code></pre> <p>Return the dynamic input field description.</p> Source code in <code>src/atlas/server.py</code> <pre><code>def build_input_help(atlas: Atlas) -&gt; str:\n    \"\"\"Return the dynamic input field description.\"\"\"\n    if not atlas.is_initialized:\n        return (\n            \"Atlas command string. \"\n            \"Examples: 'init', 'list', 'list modules'\"\n        )\n\n    examples: list[str] = []\n    for name in atlas.installed_modules[:3]:\n        examples.append(f\"'{name}'\")\n    if len(atlas.installed_modules) &gt; 1:\n        pair = \", \".join(atlas.installed_modules[:2])\n        examples.append(f\"'{pair}'\")\n\n    example_str = \", \".join(examples) if examples else \"'python', 'python linter'\"\n    return (\n        f\"Atlas command string. \"\n        f\"Retrieve: {example_str}. \"\n        f\"Verb: 'add &lt;module&gt;', 'just &lt;task&gt;', 'list modules'. \"\n        f\"Passthrough: '&lt;module&gt; -- &lt;message&gt;'.\"\n    )\n</code></pre>"},{"location":"api/server/#atlas.server.main_sync","title":"main_sync","text":"<pre><code>main_sync() -&gt; None\n</code></pre> <p>Synchronous entry point for console_scripts.</p> Source code in <code>src/atlas/server.py</code> <pre><code>def main_sync() -&gt; None:\n    \"\"\"Synchronous entry point for console_scripts.\"\"\"\n    import asyncio\n\n    async def _run() -&gt; None:\n        async with stdio_server() as streams:\n            await server.run(streams[0], streams[1], server.create_initialization_options())\n\n    asyncio.run(_run())\n</code></pre>"},{"location":"guides/api/","title":"Verbs &amp; API","text":"<p>Atlas exposes one MCP tool \u2014 <code>atlas</code> \u2014 with a single string input. The input is parsed into a verb + query.</p>"},{"location":"guides/api/#syntax","title":"Syntax","text":"<pre><code>&lt;verb&gt; &lt;query&gt;\n&lt;verb&gt; &lt;filter1&gt; &lt;filter2&gt;     # spaces = AND filter\n&lt;verb&gt; &lt;moduleA&gt;,&lt;moduleB&gt;     # commas = combine multiple modules\n&lt;verb&gt; &lt;query&gt; -- &lt;passthrough&gt; # -- separates atlas args from tool args\n</code></pre>"},{"location":"guides/api/#the-10-verbs","title":"The 10 verbs","text":""},{"location":"guides/api/#init","title":"<code>init</code>","text":"<p>Detect the project stack and install suggested modules.</p> <pre><code>init\ninit --yes        # accept all suggestions without prompting\n</code></pre>"},{"location":"guides/api/#retrieve","title":"<code>retrieve</code>","text":"<p>Return pre-built context for one or more modules.</p> <pre><code>retrieve python\nretrieve ruff\nretrieve python ruff pytest     # multiple filters (AND)\nretrieve python,ruff,pytest     # combine into one response\nretrieve ruff select            # filter to sections matching \"select\"\n</code></pre>"},{"location":"guides/api/#add","title":"<code>add</code>","text":"<p>Install a module from the warehouse.</p> <pre><code>add ruff\nadd django postgresql\n</code></pre>"},{"location":"guides/api/#remove","title":"<code>remove</code>","text":"<p>Uninstall a module.</p> <pre><code>remove flake8\n</code></pre>"},{"location":"guides/api/#sync","title":"<code>sync</code>","text":"<p>Re-scan config files and update stored values.</p> <pre><code>sync\n</code></pre>"},{"location":"guides/api/#update","title":"<code>update</code>","text":"<p>Pull latest module bundles from the warehouse.</p> <pre><code>update\nupdate ruff        # update a specific module only\n</code></pre>"},{"location":"guides/api/#status","title":"<code>status</code>","text":"<p>Show project state: installed modules, active task, recent history, git status.</p> <pre><code>status\n</code></pre>"},{"location":"guides/api/#just","title":"<code>just</code>","text":"<p>Run a project task with error augmentation.</p> <pre><code>just test\njust lint\njust test -- -k scanner     # passthrough args to the tool\n</code></pre>"},{"location":"guides/api/#note","title":"<code>note</code>","text":"<p>Add or remove a tribal knowledge note on a module.</p> <pre><code>note ruff \"always run ruff before committing\"\nnote remove ruff 1\n</code></pre>"},{"location":"guides/api/#notes","title":"<code>notes</code>","text":"<p>List all notes for a module.</p> <pre><code>notes ruff\nnotes pytest\n</code></pre>"},{"location":"guides/api/#special-prompt-retrieval","title":"Special: prompt retrieval","text":"<p>If the verb is not one of the 10 above, Atlas treats the whole input as a prompt name:</p> <pre><code>design\nreview\ndebug\nking-mode\ndesign -- src/auth/login.py     # with file context\n</code></pre>"},{"location":"guides/configuration/","title":"Configuration","text":""},{"location":"guides/configuration/#project-config-atlasconfigjson","title":"Project config: <code>.atlas/config.json</code>","text":"<p>Override Atlas defaults for a specific project:</p> <pre><code>{\n  \"retrieve\": {\n    \"max_sections\": 10,\n    \"include_notes\": true\n  },\n  \"tasks\": {\n    \"test\": \"uv run pytest\",\n    \"lint\": \"uv run ruff check src/\",\n    \"fmt\": \"uv run ruff format src/\"\n  }\n}\n</code></pre>"},{"location":"guides/configuration/#global-config-atlasconfigjson","title":"Global config: <code>~/.atlas/config.json</code>","text":"<p>Defaults applied to all projects:</p> <pre><code>{\n  \"auto_install_policy\": \"suggest\",\n  \"allow_file_deletion\": false\n}\n</code></pre>"},{"location":"guides/configuration/#config-hierarchy","title":"Config hierarchy","text":"<p>Project config &gt; global config &gt; built-in defaults.</p>"},{"location":"guides/configuration/#task-shortcuts","title":"Task shortcuts","text":"<p>Define project tasks in <code>.atlas/config.json</code> under <code>tasks</code>. These become available via <code>atlas just &lt;name&gt;</code>:</p> <pre><code>{\n  \"tasks\": {\n    \"test\": \"uv run pytest tests/ -v\",\n    \"test-fast\": \"uv run pytest -n auto\",\n    \"lint\": \"uv run ruff check src/ tests/\",\n    \"typecheck\": \"uv run basedpyright src/\"\n  }\n}\n</code></pre> <p>Then in your editor:</p> <pre><code>atlas just test\natlas just lint\n</code></pre>"},{"location":"guides/contributing/","title":"Contributing","text":""},{"location":"guides/contributing/#setup","title":"Setup","text":"<pre><code>git clone https://github.com/Tomosius/atlas\ncd atlas\njust setup\n</code></pre>"},{"location":"guides/contributing/#workflow","title":"Workflow","text":"<ol> <li>Find an issue: <code>just issue-next</code></li> <li>Start it: <code>just issue-start &lt;number&gt;</code></li> <li>Write code with atomic commits (see Commit Rules)</li> <li>Verify: <code>just check</code></li> <li>Close: <code>just issue-done &lt;number&gt;</code></li> </ol>"},{"location":"guides/contributing/#standards","title":"Standards","text":"<ul> <li>Follow the coding standards in DEVELOPMENT.md</li> <li>Google-style docstrings on all public APIs</li> <li>Tests required for all new code (<code>just test-cov</code> must stay \u2265 80%)</li> <li><code>just check</code> must pass before any PR</li> </ul>"},{"location":"guides/contributing/#submitting-a-pr","title":"Submitting a PR","text":"<p>Use the PR template \u2014 it has a checklist. All CI checks must pass.</p>"},{"location":"guides/how-it-works/","title":"How Atlas Works","text":""},{"location":"guides/how-it-works/#the-core-idea-pre-compute-then-read","title":"The core idea: pre-compute, then read","text":"<p>Atlas never computes anything at serve time. When you run <code>atlas init</code>, <code>atlas add</code>, or <code>atlas sync</code>, it:</p> <ol> <li>Detects your project stack</li> <li>Loads module bundles from the warehouse</li> <li>Scans your config files for real values</li> <li>Injects those values into the module's <code>rules.md</code></li> <li>Writes the result to <code>.atlas/retrieve/&lt;module&gt;.md</code></li> </ol> <p>When an agent calls <code>atlas retrieve ruff</code>, Atlas reads that pre-built file from disk \u2014 instant.</p>"},{"location":"guides/how-it-works/#architecture","title":"Architecture","text":"<pre><code>Agent\n  \u2502\n  \u2502  atlas retrieve ruff\n  \u25bc\nMCP Server (server.py)\n  \u2502  parse input \u2192 route to runtime\n  \u25bc\nAtlas Runtime (runtime.py)\n  \u2502  read .atlas/retrieve/ruff.md\n  \u25bc\nPre-built retrieve file (instant file read)\n</code></pre>"},{"location":"guides/how-it-works/#the-atlas-directory","title":"The .atlas directory","text":"<p>Atlas stores all project state in <code>.atlas/</code> at your project root:</p> <pre><code>.atlas/\n  manifest.json        # installed modules + versions\n  config.json          # project-level config overrides\n  retrieve/\n    python.md          # pre-built retrieve file for python module\n    ruff.md            # pre-built retrieve file with your actual ruff config\n    pytest.md          # ...\n  notes/\n    ruff.md            # tribal knowledge notes you've added\n  history.jsonl        # append-only operation log\n</code></pre>"},{"location":"guides/how-it-works/#module-bundles","title":"Module bundles","text":"<p>Each module in the warehouse ships as:</p> <pre><code>modules/linters/ruff/\n  module.json    # metadata: category, detect_files, conflicts_with, ...\n  rules.md       # template with {{line-length}} placeholders\n</code></pre> <p>At init/sync time, Atlas replaces <code>{{line-length}}</code> with your actual value from <code>pyproject.toml</code>.</p>"},{"location":"guides/how-it-works/#truth-hierarchy","title":"Truth hierarchy","text":"<p>When a value exists in multiple places, Atlas uses this priority:</p> <ol> <li>Your config files (<code>pyproject.toml</code>, <code>.eslintrc</code>, etc.) \u2014 highest truth</li> <li><code>.atlas/modules/</code> overrides</li> <li>Warehouse defaults \u2014 lowest truth</li> </ol>"},{"location":"guides/how-it-works/#dynamic-tool-description","title":"Dynamic tool description","text":"<p>The MCP tool description changes based on what modules are installed. An agent connecting to a Python+ruff project sees different verbs and options than one connecting to a TypeScript+ESLint project.</p>"},{"location":"guides/installation/","title":"Installation","text":""},{"location":"guides/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or newer</li> <li>An MCP-compatible editor (Claude Desktop, Zed, Cursor, etc.)</li> </ul>"},{"location":"guides/installation/#zero-install-recommended","title":"Zero-install (recommended)","text":"<pre><code># No installation needed \u2014 uvx runs atlas-mcp in an isolated env\nuvx atlas-mcp\n</code></pre> <p>Configure your editor to use <code>uvx</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"atlas\": {\n      \"command\": \"uvx\",\n      \"args\": [\"atlas-mcp\"]\n    }\n  }\n}\n</code></pre>"},{"location":"guides/installation/#install-as-a-global-tool","title":"Install as a global tool","text":"<pre><code>uv tool install atlas-mcp\n# or\npipx install atlas-mcp\n</code></pre>"},{"location":"guides/installation/#install-into-a-project-venv","title":"Install into a project venv","text":"<pre><code>uv add atlas-mcp\n# or\npip install atlas-mcp\n</code></pre>"},{"location":"guides/installation/#verify-installation","title":"Verify installation","text":"<pre><code>atlas --version\natlas status\n</code></pre>"},{"location":"guides/modules/","title":"Modules","text":"<p>Modules are the knowledge units in Atlas. Each module teaches agents how to work with a specific tool, language, or framework.</p>"},{"location":"guides/modules/#module-categories","title":"Module categories","text":"Category Examples <code>language</code> python, typescript, rust, go, java <code>linter</code> ruff, eslint, clippy, golangci-lint <code>formatter</code> prettier, rustfmt, gofmt <code>testing</code> pytest, vitest, jest, playwright <code>framework</code> django, fastapi, react, next-js, svelte <code>database</code> postgresql, sqlite, redis, mongodb <code>vcs</code> git, svn <code>platform</code> github, gitlab, bitbucket <code>pkg_manager</code> uv, pnpm, npm, cargo, poetry <code>environment</code> docker, docker-compose, venv <code>ci_cd</code> github-actions, gitlab-ci <code>stack</code> python-backend, ts-frontend, fullstack <code>tool</code> commit-rules <code>prompt</code> design, review, debug, king-mode"},{"location":"guides/modules/#module-lifecycle","title":"Module lifecycle","text":"<pre><code>add ruff      \u2192 validate \u2192 load bundle \u2192 scan config \u2192 enrich \u2192 write retrieve file\nremove ruff   \u2192 validate \u2192 delete retrieve file \u2192 update manifest\nsync          \u2192 re-scan config \u2192 update changed values \u2192 rebuild retrieve files\nupdate        \u2192 compare versions \u2192 re-enrich if newer\n</code></pre>"},{"location":"guides/modules/#module-bundle-structure","title":"Module bundle structure","text":"<p>Each module in the warehouse is a directory:</p> <pre><code>modules/linters/ruff/\n  module.json    # metadata\n  rules.md       # rules template with {{placeholders}}\n</code></pre>"},{"location":"guides/modules/#modulejson-fields","title":"module.json fields","text":"<pre><code>{\n  \"name\": \"ruff\",\n  \"category\": \"linter\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Fast Python linter and formatter\",\n  \"detect_files\": [\"pyproject.toml\", \".ruff.toml\", \"ruff.toml\"],\n  \"combines_with\": [\"python\", \"pytest\"],\n  \"conflicts_with\": [\"flake8\", \"pylint\"],\n  \"config_keys\": [\"line-length\", \"select\", \"ignore\", \"extend-ignore\"],\n  \"unlocks_verb\": null\n}\n</code></pre>"},{"location":"guides/modules/#rulesmd-placeholders","title":"rules.md placeholders","text":"<pre><code>## Ruff Configuration\n\nLine length: **{{line-length}}**\nSelected rules: `{{select}}`\nIgnored rules: `{{ignore}}`\n</code></pre> <p>Atlas replaces <code>{{line-length}}</code> with the actual value from your <code>pyproject.toml</code> at sync time.</p>"},{"location":"guides/modules/#conflict-detection","title":"Conflict detection","text":"<p>Some modules conflict. Atlas checks <code>conflicts_with</code> on <code>add</code> and warns:</p> <pre><code>atlas add flake8\n\u2192 Warning: flake8 conflicts with ruff (already installed). Remove ruff first.\n</code></pre>"},{"location":"guides/modules/#creating-a-module","title":"Creating a module","text":"<p>See <code>plan/08-MODULE-SPEC.md</code> for the full spec and required fields.</p>"},{"location":"guides/quickstart/","title":"Quick Start","text":""},{"location":"guides/quickstart/#1-initialise-your-project","title":"1. Initialise your project","text":"<p>Navigate to your project root and run:</p> <pre><code>atlas init\n</code></pre> <p>Atlas will detect your stack (languages, tools, frameworks) and suggest modules to install.</p>"},{"location":"guides/quickstart/#2-ask-the-agent-for-context","title":"2. Ask the agent for context","text":"<p>In your editor, the agent can now call:</p> <pre><code>atlas retrieve python\natlas retrieve ruff\natlas retrieve pytest\n</code></pre> <p>Each call returns a Markdown document with your actual config values injected.</p>"},{"location":"guides/quickstart/#3-run-tasks-with-error-augmentation","title":"3. Run tasks with error augmentation","text":"<pre><code>atlas just test\natlas just lint\n</code></pre> <p>Atlas runs the command and appends relevant rule hints next to any errors.</p>"},{"location":"guides/quickstart/#4-add-more-modules","title":"4. Add more modules","text":"<pre><code>atlas add django\natlas add postgresql\n</code></pre>"},{"location":"guides/quickstart/#5-keep-in-sync","title":"5. Keep in sync","text":"<p>When you change config files, run:</p> <pre><code>atlas sync\n</code></pre> <p>Atlas re-scans your config files and updates stored values.</p>"},{"location":"reference/modules-overview/","title":"Module Catalogue","text":"<p>All 61 modules shipped with Atlas, organised by category.</p>"},{"location":"reference/modules-overview/#languages","title":"Languages","text":"Module Detects Conflicts <code>python</code> <code>pyproject.toml</code>, <code>setup.py</code>, <code>requirements.txt</code> \u2014 <code>typescript</code> <code>tsconfig.json</code> \u2014 <code>rust</code> <code>Cargo.toml</code> \u2014 <code>go</code> <code>go.mod</code> \u2014 <code>java</code> <code>pom.xml</code>, <code>build.gradle</code> \u2014 <code>ruby</code> <code>Gemfile</code> \u2014 <code>cpp</code> <code>CMakeLists.txt</code>, <code>*.cpp</code> \u2014 <code>csharp</code> <code>*.csproj</code>, <code>*.sln</code> \u2014 <code>html</code> <code>*.html</code> \u2014 <code>css</code> <code>*.css</code> \u2014"},{"location":"reference/modules-overview/#linters","title":"Linters","text":"Module Detects Conflicts <code>ruff</code> <code>pyproject.toml [tool.ruff]</code>, <code>.ruff.toml</code> <code>flake8</code>, <code>pylint</code> <code>eslint</code> <code>.eslintrc*</code>, <code>eslint.config.*</code> <code>biome</code> <code>biome</code> <code>biome.json</code> <code>eslint</code>, <code>prettier</code> <code>clippy</code> <code>Cargo.toml</code> \u2014 <code>flake8</code> <code>.flake8</code>, <code>setup.cfg [flake8]</code> <code>ruff</code> <code>golangci-lint</code> <code>.golangci.yml</code> \u2014"},{"location":"reference/modules-overview/#formatters","title":"Formatters","text":"Module Detects Conflicts <code>prettier</code> <code>.prettierrc*</code>, <code>prettier.config.*</code> <code>biome</code> <code>rustfmt</code> <code>rustfmt.toml</code> \u2014 <code>gofmt</code> <code>go.mod</code> \u2014"},{"location":"reference/modules-overview/#testing","title":"Testing","text":"Module Detects Conflicts <code>pytest</code> <code>pyproject.toml [tool.pytest*]</code>, <code>pytest.ini</code> \u2014 <code>vitest</code> <code>vitest.config.*</code> <code>jest</code> <code>jest</code> <code>jest.config.*</code> <code>vitest</code> <code>playwright</code> <code>playwright.config.*</code> \u2014 <code>cargo-test</code> <code>Cargo.toml</code> \u2014 <code>go-test</code> <code>go.mod</code> \u2014"},{"location":"reference/modules-overview/#frameworks","title":"Frameworks","text":"Module Detects Combines well with <code>django</code> <code>manage.py</code>, <code>django.core</code> in deps <code>python</code>, <code>postgresql</code> <code>fastapi</code> <code>fastapi</code> in deps <code>python</code>, <code>postgresql</code> <code>flask</code> <code>flask</code> in deps <code>python</code> <code>react</code> <code>react</code> in <code>package.json</code> <code>typescript</code> <code>next-js</code> <code>next.config.*</code> <code>typescript</code>, <code>react</code> <code>svelte</code> <code>svelte.config.*</code> <code>typescript</code> <code>vue</code> <code>vue.config.*</code> <code>typescript</code> <code>express</code> <code>express</code> in <code>package.json</code> <code>typescript</code> <code>angular</code> <code>angular.json</code> <code>typescript</code> <code>nestjs</code> <code>nest-cli.json</code> <code>typescript</code>"},{"location":"reference/modules-overview/#databases","title":"Databases","text":"Module Detects <code>postgresql</code> <code>psycopg*</code> or <code>asyncpg</code> in deps <code>sqlite</code> <code>sqlite3</code> usage <code>redis</code> <code>redis</code> in deps <code>mongodb</code> <code>pymongo</code> or <code>motor</code> in deps"},{"location":"reference/modules-overview/#vcs","title":"VCS","text":"Module Detects <code>git</code> <code>.git/</code> directory <code>svn</code> <code>.svn/</code> directory <code>mercurial</code> <code>.hg/</code> directory"},{"location":"reference/modules-overview/#platforms","title":"Platforms","text":"Module Detects <code>github</code> <code>.github/</code> directory <code>gitlab</code> <code>.gitlab-ci.yml</code> <code>bitbucket</code> <code>bitbucket-pipelines.yml</code>"},{"location":"reference/modules-overview/#package-managers","title":"Package Managers","text":"Module Detects <code>uv</code> <code>uv.lock</code> <code>pnpm</code> <code>pnpm-lock.yaml</code> <code>npm</code> <code>package-lock.json</code> <code>yarn</code> <code>yarn.lock</code> <code>bun</code> <code>bun.lockb</code> <code>cargo</code> <code>Cargo.lock</code> <code>poetry</code> <code>poetry.lock</code> <code>pip</code> <code>requirements.txt</code>"},{"location":"reference/modules-overview/#environments","title":"Environments","text":"Module Detects <code>docker</code> <code>Dockerfile</code> <code>docker-compose</code> <code>docker-compose.yml</code> <code>venv</code> <code>.venv/</code> <code>node</code> <code>.nvmrc</code>, <code>.node-version</code>"},{"location":"reference/modules-overview/#cicd","title":"CI/CD","text":"Module Detects <code>github-actions</code> <code>.github/workflows/*.yml</code> <code>gitlab-ci</code> <code>.gitlab-ci.yml</code> <code>circleci</code> <code>.circleci/config.yml</code>"},{"location":"reference/modules-overview/#stacks","title":"Stacks","text":"<p>Pre-bundled combinations for common project types:</p> Stack Includes <code>python-backend</code> python + uv + ruff + pytest + git <code>python-cli</code> python + uv + ruff + pytest + git <code>python-library</code> python + uv + ruff + pytest + git <code>ts-frontend</code> typescript + pnpm + eslint + vitest <code>ts-backend</code> typescript + pnpm + eslint + jest <code>fullstack</code> python + typescript + uv + pnpm"},{"location":"reference/modules-overview/#tools","title":"Tools","text":"Module Purpose <code>commit-rules</code> Semantic commit message conventions"},{"location":"reference/modules-overview/#prompts","title":"Prompts","text":"Module Purpose <code>design</code> Senior engineer design review prompt <code>review</code> Code review prompt with language + linter fragments <code>debug</code> Debugging prompt with language + testing context <code>king-mode</code> High-discipline senior engineer mode"}]}